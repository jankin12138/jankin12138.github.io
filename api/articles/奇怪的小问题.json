{"title":"奇怪的小问题","uid":"5f1d861065ff3b07fbdc6d6fa1d8207a","slug":"奇怪的小问题","date":"2022-10-13T08:14:34.000Z","updated":"2022-10-19T15:32:58.047Z","comments":true,"path":"api/articles/奇怪的小问题.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/QQ截图20221013184546.3gx9eojoene0.webp","content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这个文章主要是记录一些平常突发奇想的一些小问题，所以没有什么顺序，如果你也有同样的疑惑希望可以帮到你。</p></blockquote>\n<h1 id=\"DFS先判断后递归还是先递归后判断\"><a href=\"#DFS先判断后递归还是先递归后判断\" class=\"headerlink\" title=\"DFS先判断后递归还是先递归后判断\"></a>DFS先判断后递归还是先递归后判断</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>今天像往常一样在写DFS突然冒出了一个奇怪的想法，究竟应该先递归还是应该先判断，然后就有了这个问题的探究。先说结论：<strong>都可以，几乎没有区别，虽然从最底层的角度看先判断优于先递归，毕竟省略了函数调用，但实际上影响非常有限。</strong></p></blockquote>\n<p>先上测试代码：asdasdasdsad</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace  std;\n\nvoid dfs1(vector&lt;vector&lt;int&gt;&gt;&amp; tmp, int i, int j,int target)&#123;\n    &#x2F;&#x2F;if(tmp[i][j] !&#x3D; target) return;\n    tmp[i][j] ++;\n    &#x2F;&#x2F;cout&lt;&lt;sum&lt;&lt;endl;\n    if(i &lt; 99 &amp;&amp; tmp[i+1][j] &#x3D;&#x3D; target) dfs1(tmp,i+1,j,target);\n    if(i &gt; 0 &amp;&amp; tmp[i-1][j]  &#x3D;&#x3D; target ) dfs1(tmp,i-1,j,target);\n    if(j &lt; 99 &amp;&amp; tmp[i][j+1]  &#x3D;&#x3D; target ) dfs1(tmp, i,j+1,target);\n    if(j &gt; 0 &amp;&amp; tmp[i][j-1]  &#x3D;&#x3D; target ) dfs1(tmp, i,j-1,target);\n&#125;\nvoid dfs2(vector&lt;vector&lt;int&gt;&gt;&amp; tmp, int i, int j,int target)&#123;\n    if(tmp[i][j] !&#x3D; target) return;\n    tmp[i][j] ++;\n    &#x2F;&#x2F;cout&lt;&lt;sum&lt;&lt;endl;\n    if(i &lt; 99 ) dfs1(tmp,i+1,j,target);\n    if(i &gt; 0 ) dfs1(tmp,i-1,j,target);\n    if(j &lt; 99) dfs1(tmp, i,j+1,target);\n    if(j &gt; 0) dfs1(tmp, i,j-1,target);\n&#125;\n\nint main() &#123;\n    int count &#x3D; 0;\n    for(int j &#x3D; 0;j&lt;100;j++)&#123;\n        double time1 &#x3D;0,time2 &#x3D;0;\n        clock_t startTime,endTime;\n        vector&lt;vector&lt;int&gt;&gt; tmp(100,vector&lt;int&gt;(100,0));\n        vector&lt;vector&lt;int&gt;&gt; tmp1(100,vector&lt;int&gt;(100,0));\n        startTime &#x3D; clock();\n        for(int i &#x3D;0; i &lt; 1000;i++)&#123;\n            dfs2(tmp,0,0,i);\n        &#125;\n        &#x2F;&#x2F;cout&lt;&lt;sum;\n        endTime &#x3D; clock();\n        time1 &#x3D; (double)(endTime - startTime) &#x2F; CLOCKS_PER_SEC;\n        cout&lt;&lt;&quot;先判断：&quot;&lt;&lt;(double)(endTime - startTime) &#x2F; CLOCKS_PER_SEC&lt;&lt;endl;\n        startTime &#x3D; clock();\n        for(int i &#x3D;0; i &lt; 1000;i++)&#123;\n            dfs2(tmp1,0,0,i);\n        &#125;\n        endTime &#x3D; clock();\n        time2 &#x3D; (double)(endTime - startTime) &#x2F; CLOCKS_PER_SEC;\n        cout&lt;&lt;&quot;先递归：&quot;&lt;&lt;(double)(endTime - startTime) &#x2F; CLOCKS_PER_SEC&lt;&lt;endl;\n        if(time1&gt;time2) count--;\n        if(time2&gt;time1) count++;\n    &#125;\n    cout&lt;&lt;&quot;总次数:&quot;&lt;&lt;&quot;100\\t&quot;&lt;&lt;&quot;先判断比先递归快的次数：&quot;&lt;&lt;count&lt;&lt;endl;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这里顺便提一嘴，递归深度真的很有限哈哈哈。</p>\n<p>先说测试结论：两者快慢好像就是单纯的程序波动。</p>\n<p>我分别测试了好几组，发现每次结论的波动都非常大，而且即使是同一个程序使用两个一样的方法也会有很大的波动，所以看起来这里的影响已经是微乎其微的了。</p>\n<p>因此和我们常规感觉一致递归是调用自身的函数，而函数的每次调用都会在栈中产生调用帧（call frame, 用来保存内部变量、返回点等信息），可栈的空间是有限的，没法一次同时保存过多的调用帧。所以如果调用的次数多了就容易导致栈溢出，对空间消耗大。</p>\n<p>那么在条件允许的情况下先判断也不错，当然由于性能的影响微乎其微所以怎么做也完全可以根据代码简洁度和规范决定。</p>\n<h1 id=\"i-和-i的效率问题\"><a href=\"#i-和-i的效率问题\" class=\"headerlink\" title=\"i++和++i的效率问题\"></a>i++和++i的效率问题</h1><p>C语言中的 i++ 和 ++i 是有区别的，这就有可能带来效率上的差异。如果有代码关心 i++ 执行时的 i 当前值，程序在对 i 进行自加操作时，将不得不先保存 i 的当前值，而 ++i 就无需保存当前值，这就会带来效率上的差异。如果没人关心 i++ 的当前值，那么现代大多数C语言编译器将会将这一差异优化掉，此时 i++ 和 ++i 不再有效率上的差异。</p>\n<p>数组越界的处理问题</p>\n<h1 id=\"数组越界问题\"><a href=\"#数组越界问题\" class=\"headerlink\" title=\"数组越界问题\"></a>数组越界问题</h1><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int a[10];\nfor (int i &#x3D; 0; i &lt;&#x3D; 12; i++)\n&#123;\n\ta[i] &#x3D; i;\n\tcout &lt;&lt;  a+i &lt;&lt; endl;\n&#125;\ncout &lt;&lt; a[12] &lt;&lt; endl;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>运行上述程序发现会无限循环输出0，因为数组大小为3，下标最大到2，而上述代码因为书写问题，导致for循环的最大索引访问到了3，数组a[3]访问越界，在C++中，只要不是访问受限的内存，所有的内存空间都可以自由访问，根据上面的数组寻址公式，a[3]会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量i的内存地址，也就是i的指针指向了&amp;a[3]，那么a[3]&#x3D;0相当与i&#x3D;0，所以会导致代码无限循环。</p></blockquote>\n<p>但目前已经没有这个问题，在数组越界的情况下，数组仍然可以被正常调用，因为越界值不再被作为野指针，而是会继续在数组边界之后连续的被声明，非常有意思。</p>\n<p>并且会在程序的最后弹出数组越界的错误，也就是说当有数组越界时程序仍然可以正常执行，但是越界的定位却难以捉摸，因为指针的不确定性。所以在对数组进行管理时要格外小心。</p>\n<h1 id=\"main函数含参问题\"><a href=\"#main函数含参问题\" class=\"headerlink\" title=\"main函数含参问题\"></a>main函数含参问题</h1><p>[[邓俊辉学习笔记#main函数含参]]</p>\n<h1 id=\"类与结构体的定义\"><a href=\"#类与结构体的定义\" class=\"headerlink\" title=\"类与结构体的定义\"></a>类与结构体的定义</h1><p><strong>概念：</strong>class和struct的语法基本相同，从声明到使用，都很相似，但是struct的约束要比class多，理论上，struct能做到的class都能做到，但class能做到的stuct却不一定做的到<br><strong>类型：</strong>struct是值类型，class是引用类型，因此它们具有所有值类型和引用类型之间的差异<br><strong>效率：</strong>由于堆栈的执行效率要比堆的执行效率高，但是堆栈资源却很有限，不适合处理逻辑复杂的大对象，因此struct常用来处理作为基类型对待的小对象，而class来处理某个商业逻辑<br><strong>关系：</strong>struct不仅能继承也能被继承 ，而且可以实现接口，不过Class可以完全扩展。内部结构有区别，struct只能添加带参的构造函数，不能使用abstract和protected等修饰符，不能初始化实例字段</p>\n<h1 id=\"全局变量与局部变量的生命周期\"><a href=\"#全局变量与局部变量的生命周期\" class=\"headerlink\" title=\"全局变量与局部变量的生命周期\"></a>全局变量与局部变量的生命周期</h1><p><a href=\"https://blog.csdn.net/qq_20386411/article/details/89415041\">C&#x2F;C++变量的生命周期和static_山人自有锦囊妙计的博客-CSDN博客_c++成员变量生命周期</a></p>\n<h1 id=\"stl中size的问题\"><a href=\"#stl中size的问题\" class=\"headerlink\" title=\"stl中size的问题\"></a>stl中size的问题</h1><p>使用size减一个数的时候一定不能小于0，因为size是unsigned int，所以小于0还返回2^64次方-1。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">    while(nums[nums.size()-count]&gt;&#x3D;i)&#123;\n    \tcount++;\n    cout&lt;&lt;nums.size()&lt;&lt;count&lt;&lt;endl;\n    cout&lt;&lt;nums.size()-count&lt;&lt;endl;\n    &#125;\nscout:\n    22\n    0\n    23\n    18446744073709551615<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","text":" 这个文章主要是记录一些平常突发奇想的一些小问题，所以没有什么顺序，如果你也有同样的疑惑希望可以帮到你。 DFS先判断后递归还是先递归后判断 今天像往常一样在写DFS突然冒出了一个奇怪的想法，究竟应该先递归还是应该先判断，然后就有了这个问题的探究。先说结论：都可以，几乎没有区别，...","link":"","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[{"name":"日常记录","slug":"日常记录","count":1,"path":"api/categories/日常记录.json"}],"tags":[{"name":"日常记录","slug":"日常记录","count":1,"path":"api/tags/日常记录.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#DFS%E5%85%88%E5%88%A4%E6%96%AD%E5%90%8E%E9%80%92%E5%BD%92%E8%BF%98%E6%98%AF%E5%85%88%E9%80%92%E5%BD%92%E5%90%8E%E5%88%A4%E6%96%AD\"><span class=\"toc-text\">DFS先判断后递归还是先递归后判断</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#i-%E5%92%8C-i%E7%9A%84%E6%95%88%E7%8E%87%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">i++和++i的效率问题</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">数组越界问题</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#main%E5%87%BD%E6%95%B0%E5%90%AB%E5%8F%82%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">main函数含参问题</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">类与结构体的定义</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">全局变量与局部变量的生命周期</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#stl%E4%B8%ADsize%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">stl中size的问题</span></a></li></ol>","author":{"name":"依水何安","slug":"blog-author","avatar":"/img/123.png","link":"/","description":"一个抽象的码农","socials":{"github":"https://github.com/jankin12138","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/img/bilibili.png","link":"https://space.bilibili.com/14624621?spm_id_from=333.1007.0.0"},"leetcode":{"icon":"/img/leetcode.png","link":"https://leetcode.cn/u/yi-shui-he-an-o/"}}}},"mapped":true,"prev_post":{"title":"mysql常用语句","uid":"d198ad69ab98260fa3db17c94f83ffaa","slug":"mysql常用语句","date":"2022-10-17T09:13:29.000Z","updated":"2022-10-19T15:49:44.540Z","comments":true,"path":"api/articles/mysql常用语句.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/QQ截图20221017172054.3b034g09kf40.webp","text":" 这一章是纯粹的个人笔记，所以不会按照目录的方式分类各种语句，因为有点麻烦，如果有空的话可能会整理吧，主要还是注释形式来记录一些语句的用法（因为我的mysql使用的是DataGrip所以可以比较方便的记录语句，如果有兴趣我也可以出一期安装和配置mysql已经DG的教程） #使用M...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"数据库","slug":"数据库","count":7,"path":"api/categories/数据库.json"}],"tags":[{"name":"MySQL","slug":"MySQL","count":7,"path":"api/tags/MySQL.json"},{"name":"框架学习","slug":"框架学习","count":7,"path":"api/tags/框架学习.json"},{"name":"基础概念","slug":"基础概念","count":7,"path":"api/tags/基础概念.json"}],"author":{"name":"依水何安","slug":"blog-author","avatar":"/img/123.png","link":"/","description":"一个抽象的码农","socials":{"github":"https://github.com/jankin12138","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/img/bilibili.png","link":"https://space.bilibili.com/14624621?spm_id_from=333.1007.0.0"},"leetcode":{"icon":"/img/leetcode.png","link":"https://leetcode.cn/u/yi-shui-he-an-o/"}}}}},"next_post":{"title":"csapp笔记","uid":"6e85e7b765209c5fafd1be815fdedbe2","slug":"csapp笔记","date":"2022-10-09T13:30:13.000Z","updated":"2022-10-17T17:30:19.278Z","comments":true,"path":"api/articles/csapp笔记.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/QQ截图20221009213220.3210y5s04pa0.webp","text":"程序结构与执行浮点数在机器中表示一个浮点数时需要给出指数，这个指数用整数形式表示，这个整数叫做阶码，阶码指明了小数点在数据中的位置。 阶码：对于任意一个二进制数N，可用N&#x3D;S×2^P表示，其中S为尾数，P为阶码，2为阶码的底，P、S都用二进制数表示，S表示N的全部有效数...","link":"","photos":[],"count_time":{"symbolsCount":825,"symbolsTime":"1 mins."},"categories":[{"name":"操作系统","slug":"操作系统","count":1,"path":"api/categories/操作系统.json"}],"tags":[{"name":"csapp","slug":"csapp","count":1,"path":"api/tags/csapp.json"},{"name":"操作系统","slug":"操作系统","count":1,"path":"api/tags/操作系统.json"},{"name":"计算机网络","slug":"计算机网络","count":2,"path":"api/tags/计算机网络.json"}],"author":{"name":"依水何安","slug":"blog-author","avatar":"/img/123.png","link":"/","description":"一个抽象的码农","socials":{"github":"https://github.com/jankin12138","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/img/bilibili.png","link":"https://space.bilibili.com/14624621?spm_id_from=333.1007.0.0"},"leetcode":{"icon":"/img/leetcode.png","link":"https://leetcode.cn/u/yi-shui-he-an-o/"}}}}}}