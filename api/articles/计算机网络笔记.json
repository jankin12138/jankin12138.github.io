{"title":"计算机网络笔记","uid":"09f2766bd638543cf5a9ec60a938ae77","slug":"计算机网络笔记","date":"2022-10-19T13:57:03.000Z","updated":"2022-11-05T13:56:03.451Z","comments":true,"path":"api/articles/计算机网络笔记.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/QQ截图20221019220156.4lypoz67vm60.webp","content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>本文参考了<a href=\"https://www.xiaolincoding.com/network/\">小林coding</a>以及自顶向下方法等计算机网络教程，写了一篇个人的笔记，其中也包含了本人对于一些小问题的记录和思考，以及整体框架的梳理。</p></blockquote>\n<h1 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>对于不同设备间的通信就需要使用网络通信，而设备是多样性的，所以要兼容设备就需要一套<strong>通用的网络协议</strong></p></blockquote>\n<h2 id=\"TCP-x2F-IP网络模型\"><a href=\"#TCP-x2F-IP网络模型\" class=\"headerlink\" title=\"TCP&#x2F;IP网络模型\"></a>TCP&#x2F;IP网络模型</h2><h3 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h3><p>最上层的，也是我们能直接接触到的就是<strong>应用层</strong>（<em>Application Layer</em>），我们电脑或手机使用的应用软件都是在应用层实现。那么，当两个不同设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是传输层。应用层是不用去关心数据是如何传输的，而且应用层是工作在操作系统中的<strong>用户态</strong>，传输层及以下则工作在<strong>内核态</strong>。</p>\n<p>所以，应用层只需要专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。</p>\n<h3 id=\"传输层\"><a href=\"#传输层\" class=\"headerlink\" title=\"传输层\"></a>传输层</h3><p>应用层的数据包会传给传输层，<strong>传输层</strong>（<em>Transport Layer</em>）是为应用层提供网络支持的。在传输层会有两个传输协议，分别是 <strong>TCP</strong> 和 <strong>UDP</strong>。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>TCP 的全称叫传输控制协议（<em>Transmission Control Protocol</em>），大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。</p>\n<p>UDP 相对来说就很简单，简单到只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。当然，UDP 也可以实现可靠传输，把 TCP 的特性在应用层上实现就可以，不过要实现一个商用的可靠 UDP 传输协议，也不是一件简单的事情。</p></blockquote>\n<p>应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的数据包大小超过 MSS（TCP 最大报文段长度） ，就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在 TCP 协议中，我们把每个分块称为一个 <strong>TCP 段</strong>（<em>TCP Segment</em>）。</p>\n<p>当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是<strong>端口</strong>。</p>\n<p>比如 80 端口通常是 Web 服务器用的，22 端口通常是远程登录服务器用的。而对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。</p>\n<p>由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。</p>\n<h3 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h3><p>实际的传输功能就交给下一层，也就是<strong>网络层</strong>（<em>Internet Layer</em>）。</p>\n<p>网络层最常使用的是 IP 协议（<em>Internet Protocol</em>），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会<strong>再次进行分片</strong>，得到一个即将发送到网络的 IP 报文。</p>\n<div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/12.12v3aiay57wg.webp\"/>\n</div>\n\n<p>IP 地址分成两种意义：</p>\n<ul>\n<li>一个是<strong>网络号</strong>，负责标识该 IP 地址是属于哪个「子网」的；</li>\n<li>一个是<strong>主机号</strong>，负责标识同一「子网」下的不同主机；</li>\n</ul>\n<p>需要配合<strong>子网掩码</strong>才能算出 IP 地址 的网络号和主机号。将 10.100.122.2 和 255.255.255.0 进行<strong>按位与运算</strong>，就可以得到网络号。</p>\n<p><a href=\"http://www.ab173.com/net/subnetmask.php\">在线子网掩码计算器</a></p>\n<p>这里就可以感知可用地址（主机号）和网络号之间的关系了。PS：ipv4如果是24位掩码才2^16太少了，难怪要变成ipv6。</p>\n<p>除了寻址能力， IP 协议还有另一个重要的能力就是<strong>路由</strong>。实际场景中，两台设备并不是用一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。</p>\n<p>路由器寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络内。</p>\n<div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/17.6gyhodrm3pk0.webp\"/>\n</div>\n\n<p>所以，<strong>IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘</strong>。</p>\n<h3 id=\"网络接口层\"><a href=\"#网络接口层\" class=\"headerlink\" title=\"网络接口层\"></a>网络接口层</h3><p>生成了 IP 头部之后，接下来要交给<strong>网络接口层</strong>（<em>Link Layer</em>）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。</p>\n<p>以太网在判断网络包目的地时和 IP 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 MAC 头部就是干这个用的，所以，在以太网进行通讯要用到 MAC 地址。</p>\n<p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址。</p>\n<p>所以说，网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>这里有个疑惑就是mac既然是针对局域网的为什么不是先解析ip而是先解析mac，后来找到了答案：因为从主机到网关这条路上也是逃不过数据链路层的啊。</p>\n<p>而且解析的 MAC 地址并不是远程主机的，而是网关的，如果有 ARP 缓存的话也只用解析一次。</p>\n\n</div>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/tcpip参考模型.2n9imwis2120.webp\"/>\n</div>\n\n<div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/封装.6uusbhj3bjg0.webp\"/>\n</div>\n网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。\n\n<h2 id=\"从输入网址到页面显示过程\"><a href=\"#从输入网址到页面显示过程\" class=\"headerlink\" title=\"从输入网址到页面显示过程\"></a>从输入网址到页面显示过程</h2><h3 id=\"1-解析URL\"><a href=\"#1-解析URL\" class=\"headerlink\" title=\"1.解析URL\"></a>1.解析URL</h3><div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/3.3p2vprp9nbs0.webp\"/>\n</div>\n\n<p>当没有路径名时，就代表访问根目录下事先设置的<strong>默认文件</strong>，也就是 <code>/index.html</code> 或者 <code>/default.html</code> 这些文件，这样就不会发生混乱了。</p>\n<h3 id=\"2-生成HTTP请求信息\"><a href=\"#2-生成HTTP请求信息\" class=\"headerlink\" title=\"2.生成HTTP请求信息\"></a>2.生成HTTP请求信息</h3><div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/4.4tyiv3tr6ie0.webp\"/>\n</div>\n\n<details class=\"custom-details\">\n<summary>POST和GET的区别</summary>\n<p><ol>\n<li><p>POST 和GET本质都是一样一样的。</p>\n</li>\n<li><p>POST和GET都是HTTP请求的基本方法。</p>\n</li>\n<li><p>区别主要有以下几个：</p>\n<ul>\n<li><p>GET请求在浏览器刷新或者回退的时候是无害的。POST的话数据会被重新提交。</p>\n</li>\n<li><p>GET可以被书签收藏，POST不行</p>\n</li>\n<li><p>GET可以存在缓存中。POST不行</p>\n</li>\n<li><p>GET 会将数据存在浏览器的历史中，POST不会</p>\n</li>\n<li><p>GET 编码格式只能用ASCII码，POST没有限制</p>\n</li>\n<li><p>GET 数据类型urlencode,POST是URLENCODE，form-data</p>\n</li>\n<li><p>可见性 GET的参数在URL用户可以看见，POST的参数在REQUSET BODY中不会被用户看见</p>\n</li>\n<li><p>安全性 GET相对不安全 POST相对安全些</p>\n</li>\n<li><p>长度 GET的参数一般限制2048（和WEB服务器相关），POST的参数无限制。</p>\n</li>\n</ul>\n</li>\n<li><p>GET 和POST在请求的时候</p>\n<ul>\n<li>GET 是将数据中的hearder 和 data 一起发送给服务端，返回200code</li>\n<li>POST 是先将hearder发给服务器返回100continue，再发送data给到服务器，返回200</li>\n<li>GET 就发送了一个TCP数据包给服务器而POST发送了两次TCP数据包给服务器</li>\n<li>GET和POST是已经有定义好的说明的，最好不要混用。</li>\n</ul>\n</li>\n<li><p>GET和POST本质上是一样一样的，GET可以加Request Body ，POST也可以在URL中添加参数。实现是可以的。</p>\n  <div align=center>\n  <img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/QQ截图20221020170247.21its6o9mdkw.webp\"/>\n  </div></li>\n</ol>\n</p>\n</details>\n<h3 id=\"3-真实地址查询-DNS\"><a href=\"#3-真实地址查询-DNS\" class=\"headerlink\" title=\"3.真实地址查询-DNS\"></a>3.真实地址查询-DNS</h3><p>通过浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统将消息发送给 <code>Web</code> 服务器。</p>\n<p>但在发送之前，还有一项工作需要完成，那就是<strong>查询服务器域名对应的 IP 地址</strong>，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。</p>\n<p>DNS 中的域名都是用<strong>句点</strong>来分隔的，比如 <code>www.server.com</code>，这里的句点代表了不同层次之间的<strong>界限</strong>。</p>\n<p>在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong>。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>域名解析的工作流程</p></blockquote>\n<ol>\n<li>客户端首先会发出一个 DNS 请求，问<code>www.server.com</code> 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP&#x2F;IP 设置中填写的 DNS 服务器地址）。</li>\n<li>本地域名服务器收到客户端的请求后，如果缓存里的表格能找到<code>www.server.com</code>，则它直接返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我<code>www.server.com</code>的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。</li>\n<li>根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：<code>www.server.com</code>这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”</li>\n<li>本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 <code>www.server.com</code>的 IP 地址吗？”</li>\n<li>顶级域名服务器说：“我给你负责<code>www.server.com</code>区域的权威 DNS 服务器的地址，你去问它应该能问到”。</li>\n<li>本地 DNS 于是转向问权威 DNS 服务器：“老三，<code>www.server.com</code>对应的IP是啥呀？” server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</li>\n<li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li>\n<li>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。</li>\n</ol>\n<div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/6.7lhfk43lh9s0.webp\"/>\n</div>\n\n<p>浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回，如果没有，就去问操作系统，操作系统也会去看自己的缓存，如果有，就直接返回，如果没有，再去 hosts 文件看，也没有，才会去问「本地 DNS 服务器」。</p>\n<h3 id=\"4-协议栈\"><a href=\"#4-协议栈\" class=\"headerlink\" title=\"4.协议栈\"></a>4.协议栈</h3><p>通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的<strong>协议栈</strong>。</p>\n<p>协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。</p>\n<p>应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，这两个传输协议会接受应用层的委托执行收发数据的操作。</p>\n<p>协议栈的下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。</p>\n<p>此外 IP 中还包括 <code>ICMP</code> 协议和 <code>ARP</code> 协议。</p>\n<ul>\n<li><code>ICMP</code> 用于告知网络包传送过程中产生的错误以及各种控制信息。</li>\n<li><code>ARP</code> 用于根据 IP 地址查询相应的以太网 MAC 地址。</li>\n</ul>\n<p>IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。</p>\n<h3 id=\"5-TCP\"><a href=\"#5-TCP\" class=\"headerlink\" title=\"5.TCP\"></a>5.TCP</h3><div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/8.1kmf20jpm7y8.webp\"/>\n</div>\n\n<p>首先，<strong>源端口号</strong>和<strong>目标端口</strong>号是不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。</p>\n<p>接下来有包的<strong>序</strong>号，这个是为了解决包乱序的问题。</p>\n<p>还有应该有的是<strong>确认号</strong>，目的是确认发出去对方是否有收到。如果没有收到就应该重新发送，直到送达，这个是为了解决不丢包的问题。</p>\n<p>接下来还有一些<strong>状态位</strong>。例如 <code>SYN</code> 是发起一个连接，<code>ACK</code> 是回复，<code>RST</code> 是重新连接，<code>FIN</code> 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。</p>\n<p>还有一个重要的就是<strong>窗口大小</strong>。TCP 要做<strong>流量控制</strong>，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。</p>\n<p>除了做流量控制以外，TCP还会做<strong>拥塞控制</strong>，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。不能改变世界，就改变自己嘛。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>TCP 传输数据之前，要先三次握手建立连接</p></blockquote>\n<p>在 HTTP 传输数据之前，首先需要 TCP 建立连接，TCP 连接的建立，通常称为<strong>三次握手</strong>。</p>\n<p>这个所谓的「连接」，只是双方计算机里维护一个状态机，在连接建立的过程中，双方的状态变化时序图就像这样。</p>\n<div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/TCP三次握手.ajash6b5960.webp\"/>\n</div>\n\n<ul>\n<li>一开始，客户端和服务端都处于 <code>CLOSED</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态。</li>\n<li>然后客户端主动发起连接 <code>SYN</code>，之后处于 <code>SYN-SENT</code> 状态。</li>\n<li>服务端收到发起的连接，返回 <code>SYN</code>，并且 <code>ACK</code> 客户端的 <code>SYN</code>，之后处于 <code>SYN-RCVD</code> 状态。</li>\n<li>客户端收到服务端发送的 <code>SYN</code> 和 <code>ACK</code> 之后，发送对 <code>SYN</code> 确认的 <code>ACK</code>，之后处于 <code>ESTABLISHED</code> 状态，因为它一发一收成功了。</li>\n<li>服务端收到 <code>ACK</code> 的 <code>ACK</code> 之后，处于 <code>ESTABLISHED</code> 状态，因为它也一发一收了。</li>\n</ul>\n<p>所以三次握手目的是<strong>保证双方都有发送和接收的能力</strong>。</p>\n<p>如果 HTTP 请求消息比较长，超过了 <code>MSS</code> 的长度，这时 TCP 就需要把 HTTP 的数据拆解成一块块的数据发送，而不是一次性发送所有数据。</p>\n<ul>\n<li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节。</li>\n<li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。</li>\n</ul>\n<p>数据会被以 <code>MSS</code> 的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上 TCP 头信息，然后交给 IP 模块来发送数据。</p>\n<h3 id=\"6-IP\"><a href=\"#6-IP\" class=\"headerlink\" title=\"6.IP\"></a>6.IP</h3><p>TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成<strong>网络包</strong>发送给通信对象。</p>\n<div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/14.4btlxidg9wm0.webp\"/>\n</div>\n\n<p>在 IP 协议里面需要有<strong>源地址 IP</strong> 和 <strong>目标地址 IP</strong>：</p>\n<ul>\n<li>源地址IP，即是客户端输出的 IP 地址；</li>\n<li>目标地址，即通过 DNS 域名解析得到的 Web 服务器 IP。</li>\n</ul>\n<p>因为 HTTP 是经过 TCP 传输的，所以在 IP 包头的<strong>协议号</strong>，要填写为 <code>06</code>（十六进制），表示协议为 TCP。</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">假设客户端有多个网卡，就会有多个 IP 地址，那 IP 头部的源地址应该选择哪个 IP 呢？</p>\n<p><div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/QQ截图20221020215915.36g56vq842u0.webp\"/>\n</div>\n\n\n\n<ol>\n<li>首先先和第一条目的子网掩码（<code>Genmask</code>）进行 <strong>与运算</strong>，得到结果为 <code>192.168.10.0</code>，但是第一个条目的 <code>Destination</code> 是 <code>192.168.3.0</code>，两者不一致所以匹配失败。</li>\n<li>再与第二条目的子网掩码进行 <strong>与运算</strong>，得到的结果为 <code>192.168.10.0</code>，与第二条目的 <code>Destination 192.168.10.0</code> 匹配成功，所以将使用 <code>eth1</code> 网卡的 IP 地址作为 IP 包头的源地址。</li>\n</ol>\n</p>\n</div>\n<p>那么假设 Web 服务器的目标地址是 <code>10.100.20.100</code>，那么依然依照上面的路由表规则判断，判断后的结果是和第三条目匹配。</p>\n<p>第三条目比较特殊，它目标地址和子网掩码都是 <code>0.0.0.0</code>，这表示<strong>默认网关</strong>，如果其他所有条目都无法匹配，就会自动匹配这一行。并且后续就把包发给路由器，<code>Gateway</code> 即是路由器的 IP 地址。</p>\n<h3 id=\"7-MAC\"><a href=\"#7-MAC\" class=\"headerlink\" title=\"7.MAC\"></a>7.MAC</h3><p>生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 <strong>MAC 头部</strong>。</p>\n<p>在 MAC 包头里需要<strong>发送方 MAC 地址</strong>和<strong>接收方目标 MAC 地址</strong>，用于<strong>两点之间的传输</strong>。</p>\n<p>一般在 TCP&#x2F;IP 通信里，MAC 包头的<strong>协议类型</strong>只使用：</p>\n<ul>\n<li><code>0800</code> ： IP 协议</li>\n<li><code>0806</code> ： ARP 协议</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>MAC 发送方和接收方如何确认?</p></blockquote>\n<p><strong>发送方</strong>的 MAC 地址获取就比较简单了，MAC 地址是在网卡生产时写入到 ROM 里的，只要将这个值读取出来写入到 MAC 头部就可以了。</p>\n<p><strong>接收方</strong>的 MAC 地址就有点复杂了，只要告诉以太网对方的 MAC 的地址，以太网就会帮我们把包发送过去，那么很显然这里应该填写对方的 MAC 地址。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>既然知道要发给谁，按如何获取对方的 MAC 地址呢？</p></blockquote>\n<p>所以先得搞清楚应该把包发给谁，这个只要查一下<strong>路由表</strong>就知道了。在路由表中找到相匹配的条目，然后把包发给 <code>Gateway</code> 列中的 IP 地址就可以了。</p>\n<p>ARP 协议会在以太网中以<strong>广播</strong>的形式，对以太网所有的设备喊出：“这个 IP 地址是谁的？请把你的 MAC 地址告诉我”。</p>\n<p>然后就会有人回答：“这个 IP 地址是我的，我的 MAC 地址是 XXXX”。</p>\n<p>如果对方和自己处于同一个子网中，那么通过上面的操作就可以得到对方的 MAC 地址。然后，我们将这个 MAC 地址写入 MAC 头部，MAC 头部就完成了。</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">如果在公网中如何获取MAC地址</p>\n<p>这里我犯了一个错误，犯了同一个错误，就是<strong>把广域网（或者叫公网）的网络请求中的目标地址当成是真正的 MAC 地址</strong>了。</p>\n<p>这从 Microsoft Network Monitor 中抓取的请求信息来看，向目标站点的请求头中的 MAC 地址是存在的是吧？但实际上这是我的局域网内的网关的 MAC 地址，对广域网的请求只能从网关走，那么我的目标就只能是网关。</p>\n\n</div>\n<h3 id=\"8-网卡\"><a href=\"#8-网卡\" class=\"headerlink\" title=\"8.网卡\"></a>8.网卡</h3><p>网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将<strong>数字信息转换为电信号</strong>，才能在网线上传输，也就是说，这才是真正的数据发送过程。</p>\n<p>负责执行这一操作的是<strong>网卡</strong>，要控制网卡还需要靠<strong>网卡驱动程序</strong>。</p>\n<p>网卡驱动获取网络包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong>。</p>\n<h3 id=\"9-交换机\"><a href=\"#9-交换机\" class=\"headerlink\" title=\"9.交换机\"></a>9.交换机</h3><p>下面来看一下包是如何通过交换机的。交换机的设计是将网络包<strong>原样</strong>转发到目的地。交换机工作在 MAC 层，也称为<strong>二层网络设备</strong>。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>交换机的包接收操作</p></blockquote>\n<p>首先，电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号。</p>\n<p>然后通过包末尾的 <code>FCS</code> 校验错误，如果没问题则放到缓冲区。这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。</p>\n<p>计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，<strong>交换机的端口不具有 MAC 地址</strong>。</p>\n<p>将包存入缓冲区后，接下来需要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录了。</p>\n<p>交换机的 MAC 地址表主要包含两个信息：</p>\n<ul>\n<li>一个是设备的 MAC 地址，</li>\n<li>另一个是该设备连接在交换机的哪个端口上。</li>\n</ul>\n<p>所以，<strong>交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口</strong>。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>当 MAC 地址表找不到指定的 MAC 地址会怎么样？</p></blockquote>\n<p>地址表中找不到指定的 MAC 地址。这可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被从地址表中删除了。</p>\n<p>这种情况下，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。</p>\n<p>这样做不会产生什么问题，因为以太网的设计本来就是将包发送到整个网络的，然后<strong>只有相应的接收者才接收包，而其他设备则会忽略这个包</strong>。</p>\n<p>有人会说：“这样做会发送多余的包，会不会造成网络拥塞呢？”</p>\n<p>其实完全不用过于担心，因为发送了包之后目标设备会作出响应，只要返回了响应包，交换机就可以将它的地址写入 MAC 地址表，下次也就不需要把包发到所有端口了。</p>\n<p>局域网中每秒可以传输上千个包，多出一两个包并无大碍。</p>\n<p>此外，如果接收方 MAC 地址是一个<strong>广播地址</strong>，那么交换机会将包发送到除源端口之外的所有端口。</p>\n<p>以下两个属于广播地址：</p>\n<ul>\n<li>MAC 地址中的 <code>FF:FF:FF:FF:FF:FF</code></li>\n<li>IP 地址中的 <code>255.255.255.255</code></li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>如果目标ip不在公网是如何找到路由mac的，答案就是查路由表，命令为netstat -r，如果是公网ip就会直接default然后下一跳到路由ip从而找到路由器。</p>\n<p>在发送数据包时，如果目标主机不是本地局域网，填入的MAC地址是路由器，也就是把数据包转发给路由器，路由器一直转发下一个路由器，直到转发到目标主机的路由器，发现 IP 地址是自己局域网内的主机，就会 arp 请求获取目标主机的 MAC 地址，从而转发到这个服务器主机。</p>\n<p>转发的过程中，源IP地址和目标IP地址是不会变的（前提：没有使用 NAT 网络的），源 MAC 地址和目标 MAC 地址是会变化的。</p>\n</p>\n</div>\n<h3 id=\"10-路由器\"><a href=\"#10-路由器\" class=\"headerlink\" title=\"10.路由器\"></a>10.路由器</h3><p>网络包经过交换机之后，现在到达了<strong>路由器</strong>，并在此被转发到下一个路由器或目标设备。</p>\n<p>这一步转发的工作原理和交换机类似，也是通过查表判断包转发的目标。</p>\n<p>不过在具体的操作过程上，路由器和交换机是有区别的。</p>\n<ul>\n<li>因为<strong>路由器</strong>是基于 IP 设计的，俗称<strong>三层</strong>网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；</li>\n<li>而<strong>交换机</strong>是基于以太网设计的，俗称<strong>二层</strong>网络设备，交换机的端口不具有 MAC 地址。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>路由器的包接收操作</p></blockquote>\n<p>首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 <code>FCS</code> 进行错误校验。</p>\n<p>如果没问题则检查 MAC 头部中的<strong>接收方 MAC 地址</strong>，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。</p>\n<p>总的来说，路由器的端口都具有 MAC 地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>查询路由表确定输出端口</p></blockquote>\n<p>完成包接收操作之后，路由器就会<strong>去掉</strong>包开头的 MAC 头部。</p>\n<p><strong>MAC 头部的作用就是将包送达路由器</strong>，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会<strong>被丢弃</strong>。</p>\n<p>接下来，路由器会根据 MAC 头部后方的 <code>IP</code> 头部中的内容进行包的转发操作。</p>\n<p>转发操作分为几个阶段，首先是查询<strong>路由表</strong>判断转发目标。</p>\n<p>首先，我们需要根据<strong>路由表的网关列</strong>判断对方的地址。</p>\n<ul>\n<li>如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，<strong>还未抵达终点</strong>，还需继续需要路由器转发。</li>\n<li>如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明<strong>已抵达终点</strong>。</li>\n</ul>\n<p>知道对方的 IP 地址之后，接下来需要通过 <code>ARP</code> 协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址。</p>\n<p>路由器也有 ARP 缓存，因此首先会在 ARP 缓存中查询，如果找不到则发送 ARP 查询请求。</p>\n<p>接下来是发送方 MAC 地址字段，这里填写输出端口的 MAC 地址。还有一个以太类型字段，填写 <code>0800</code> （十六进制）表示 IP 协议。</p>\n<p>网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的。</p>\n<p>发送出去的网络包会通过<strong>交换机</strong>到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。</p>\n<p>接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。</p>\n<p>不知你发现了没有，在网络包传输的过程中，<strong>源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址</strong>，因为需要 MAC 地址在以太网内进行<strong>两个设备</strong>之间的包传输。</p>\n<h3 id=\"11-数据包拆解\"><a href=\"#11-数据包拆解\" class=\"headerlink\" title=\"11.数据包拆解\"></a>11.数据包拆解</h3><div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/25.3o5llt5elmg0.webp\"/>\n</div>\n\n<p>数据包抵达服务器后，服务器会先扒开数据包的 MAC 头部，查看是否和服务器自己的 MAC 地址符合，符合就将包收起来。</p>\n<p>接着继续扒开数据包的 IP 头，发现 IP 地址符合，根据 IP 头中协议项，知道自己上层是 TCP 协议。</p>\n<p>于是，扒开 TCP 的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。TCP头部里面还有端口号， HTTP 的服务器正在监听这个端口号。</p>\n<p>于是，服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程。</p>\n<p>服务器的 HTTP 进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在 HTTP 响应报文里。</p>\n<p>HTTP 响应报文也需要穿上 TCP、IP、MAC 头部，不过这次是源地址是服务器 IP 地址，目的地址是客户端 IP 地址。</p>\n<p>穿好头部衣服后，从网卡出去，交由交换机转发到出城的路由器，路由器就把响应数据包发到了下一个路由器，就这样跳啊跳。</p>\n<p>最后跳到了客户端的城门把守的路由器，路由器扒开 IP 头部发现是要找城内的人，于是又把包发给了城内的交换机，再由交换机转发到客户端。</p>\n<p>客户端收到了服务器的响应数据包后，同样也非常的高兴，客户能拆快递了！</p>\n<p>于是，客户端开始扒皮，把收到的数据包的皮扒剩 HTTP 响应报文后，交给浏览器去渲染页面，一份特别的数据包快递，就这样显示出来了！</p>\n<p>最后，客户端要离开了，向服务器发起了 TCP 四次挥手，至此双方的连接就断开了。</p>\n<h2 id=\"Liunx系统收发网络包\"><a href=\"#Liunx系统收发网络包\" class=\"headerlink\" title=\"Liunx系统收发网络包\"></a>Liunx系统收发网络包</h2><h3 id=\"OSI七层网络模型\"><a href=\"#OSI七层网络模型\" class=\"headerlink\" title=\"OSI七层网络模型\"></a>OSI七层网络模型</h3><p>为了使得多种设备能通过网络相互通信，和为了解决各种不同设备在网络互联中的兼容性问题，国际标准化组织制定了开放式系统互联通信参考模型（<em>Open System Interconnection Reference Model</em>），也就是 OSI 网络模型，该模型主要有 7 层，分别是应用层、表示层、会话层、传输层、网络层、数据链路层以及物理层。</p>\n<p>每一层负责的职能都不同，如下：</p>\n<ul>\n<li>应用层，负责给应用程序提供统一的接口；</li>\n<li>表示层，负责把数据转换成兼容另一个系统能识别的格式；</li>\n<li>会话层，负责建立、管理和终止表示层实体之间的通信会话；</li>\n<li>传输层，负责端到端的数据传输；</li>\n<li>网络层，负责数据的路由、转发、分片；</li>\n<li>数据链路层，负责数据的封帧和差错检测，以及 MAC 寻址；</li>\n<li>物理层，负责在物理网络中传输数据帧；</li>\n</ul>\n<h2 id=\"Liunx网络协议栈\"><a href=\"#Liunx网络协议栈\" class=\"headerlink\" title=\"Liunx网络协议栈\"></a>Liunx网络协议栈</h2><div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/协议栈.4dj1tqtwp660.webp\"/>\n</div>\n\n<p>从上图的的网络协议栈，你可以看到：</p>\n<ul>\n<li>应用程序需要通过系统调用，来跟 Socket 层进行数据交互；</li>\n<li>Socket 层的下面就是传输层、网络层和网络接口层；</li>\n<li>最下面的一层，则是网卡驱动程序和硬件网卡设备；</li>\n</ul>\n<h2 id=\"Linux-接收网络包的流程\"><a href=\"#Linux-接收网络包的流程\" class=\"headerlink\" title=\"Linux 接收网络包的流程\"></a>Linux 接收网络包的流程</h2><p>网卡是计算机里的一个硬件，专门负责接收和发送网络包，当网卡接收到一个网络包后，会通过 DMA 技术，将网络包写入到指定的内存地址，也就是写入到 Ring Buffer ，这个是一个环形缓冲区，接着就会告诉操作系统这个网络包已经到达。</p>\n<h3 id=\"操作系统如何感知网络包到达\"><a href=\"#操作系统如何感知网络包到达\" class=\"headerlink\" title=\"操作系统如何感知网络包到达\"></a>操作系统如何感知网络包到达</h3><p>最简单的一种方式就是触发中断，也就是每当网卡收到一个网络包，就触发一个中断告诉操作系统。</p>\n<p>但是，这存在一个问题，在高性能网络场景下，网络包的数量会非常多，那么就会触发非常多的中断，要知道当 CPU 收到了中断，就会停下手里的事情，而去处理这些网络包，处理完毕后，才会回去继续其他事情，那么频繁地触发中断，则会导致 CPU 一直没完没了的处理中断，而导致其他任务可能无法继续前进，从而影响系统的整体效率。</p>\n<p>所以为了解决频繁中断带来的性能开销，Linux 内核在 2.6 版本中引入了 <strong>NAPI 机制</strong>，它是混合「中断和轮询」的方式来接收网络包，它的核心概念就是<strong>不采用中断的方式读取数据</strong>，而是首先采用中断唤醒数据接收的服务程序，然后 <code>poll</code> 的方法来轮询数据。</p>\n<p>因此，当有网络包到达时，会通过 DMA 技术，将网络包写入到指定的内存地址，接着网卡向 CPU 发起硬件中断，当 CPU 收到硬件中断请求后，根据中断表，调用已经注册的中断处理函数。</p>\n<p>硬件中断处理函数会做如下的事情：</p>\n<ul>\n<li>需要先「暂时屏蔽中断」，表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知 CPU 了，这样可以提高效率，避免 CPU 不停的被中断。</li>\n<li>接着，发起「软中断」，然后恢复刚才屏蔽的中断。</li>\n</ul>\n<p>至此，硬件中断处理函数的工作就已经完成。</p>\n<p>硬件中断处理函数做的事情很少，主要耗时的工作都交给软中断处理函数了。</p>\n<p>内核中的 ksoftirqd 线程专门负责<strong>软中断的处理</strong>，当 ksoftirqd 内核线程收到软中断后，就会来轮询处理数据。</p>\n<p>ksoftirqd 线程会从 Ring Buffer 中获取一个数据帧，用 sk_buff 表示，从而可以作为一个网络包交给网络协议栈进行逐层处理。</p>\n<p>这里的具体流程可以参考<a href=\"https://blog.csdn.net/youzhangjing_/article/details/124953522?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-124953522-blog-125591323.pc_relevant_recovery_v2&spm=1001.2101.3001.4242.1&utm_relevant_index=3\">Linux内核源码分析–详谈NAPI原理机制（超详细）</a></p>\n<h3 id=\"网络协议栈\"><a href=\"#网络协议栈\" class=\"headerlink\" title=\"网络协议栈\"></a>网络协议栈</h3><p>首先，会先进入到网络接口层，在这一层会检查报文的合法性，如果不合法则丢弃，合法则会找出该网络包的上层协议的类型，比如是 IPv4，还是 IPv6，接着再去掉帧头和帧尾，然后交给网络层。</p>\n<p>到了网络层，则取出 IP 包，判断网络包下一步的走向，比如是交给上层处理还是转发出去。当确认这个网络包要发送给本机后，就会从 IP 头里看看上一层协议的类型是 TCP 还是 UDP，接着去掉 IP 头，然后交给传输层。</p>\n<p>传输层取出 TCP 头或 UDP 头，根据四元组「源 IP、源端口、目的 IP、目的端口」 作为标识，找出对应的 Socket，并把数据放到 Socket 的接收缓冲区。</p>\n<p>最后，应用层程序调用 Socket 接口，将内核的 Socket 接收缓冲区的数据「拷贝」到应用层的缓冲区，然后唤醒用户进程。</p>\n<p>至此，一个网络包的接收过程就已经结束了，你也可以从下图左边部分看到网络包接收的流程，右边部分刚好反过来，它是网络包发送的流程。</p>\n<div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/收发流程.1u9wbes0fchs.webp\"/>\n</div>\n\n<h2 id=\"Linux-发送网络包的流程\"><a href=\"#Linux-发送网络包的流程\" class=\"headerlink\" title=\"Linux 发送网络包的流程\"></a>Linux 发送网络包的流程</h2><p>首先，应用程序会调用 Socket 发送数据包的接口，由于这个是系统调用，所以会从用户态陷入到内核态中的 Socket 层，内核会申请一个内核态的 sk_buff 内存，<strong>将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区</strong>。</p>\n<p>接下来，网络协议栈从 Socket 发送缓冲区中取出 sk_buff，并按照 TCP&#x2F;IP 协议栈从上到下逐层处理。</p>\n<p>如果使用的是 TCP 传输协议发送数据，那么<strong>先拷贝一个新的 sk_buff 副本</strong> ，这是因为 sk_buff 后续在调用网络层，最后到达网卡发送完成的时候，这个 sk_buff 会被释放掉。而 TCP 协议是支持丢失重传的，在收到对方的 ACK 之前，这个 sk_buff 不能被删除。所以内核的做法就是每次调用网卡发送的时候，实际上传递出去的是 sk_buff 的一个拷贝，等收到 ACK 再真正删除。</p>\n<p>接着，对 sk_buff 填充 TCP 头。这里提一下，sk_buff 可以表示各个层的数据包，在应用层数据包叫 data，在 TCP 层我们称为 segment，在 IP 层我们叫 packet，在数据链路层称为 frame。</p>\n<p><strong>为什么全部数据包只用一个结构体来描述呢？</strong>协议栈采用的是分层结构，上层向下层传递数据时需要增加包头，下层向上层数据时又需要去掉包头，如果每一层都用一个结构体，那在层之间传递数据的时候，就要发生多次拷贝，这将大大降低 CPU 效率。</p>\n<p>于是，为了在层级之间传递数据时，不发生拷贝，只用 sk_buff 一个结构体来描述所有的网络包，那它是如何做到的呢？是通过调整 sk_buff 中 <code>data</code> 的指针，比如：</p>\n<ul>\n<li>当接收报文时，从网卡驱动开始，通过协议栈层层往上传送数据报，通过增加 skb-&gt;data 的值，来逐步剥离协议首部。</li>\n<li>当要发送报文时，创建 sk_buff 结构体，数据缓存区的头部预留足够的空间，用来填充各层首部，在经过各下层协议时，通过减少 skb-&gt;data 的值来增加协议首部。</li>\n</ul>\n<div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/sk_buff.3ak1c4i6bso0.webp\"/>\n</div>\n\n<p>然后交给网络层，在网络层里会做这些工作：选取路由（确认下一跳的 IP）、填充 IP 头、netfilter 过滤、对超过 MTU 大小的数据包进行分片。处理完这些工作后会交给网络接口层处理。</p>\n<p>网络接口层会通过 ARP 协议获得下一跳的 MAC 地址，然后对 sk_buff 填充帧头和帧尾，接着将 sk_buff 放到网卡的发送队列中。</p>\n<p>这一些工作准备好后，会触发「软中断」告诉网卡驱动程序，这里有新的网络包需要发送，驱动程序会从发送队列中读取 sk_buff，将这个 sk_buff 挂到 RingBuffer 中，接着将 sk_buff 数据映射到网卡可访问的内存 DMA 区域，最后触发真实的发送。</p>\n<p>当数据发送完成以后，其实工作并没有结束，因为内存还没有清理。当发送完成的时候，网卡设备会触发一个硬中断来释放内存，主要是释放 sk_buff 内存和清理 RingBuffer 内存。</p>\n<p>最后，当收到这个 TCP 报文的 ACK 应答时，传输层就会释放原始的 sk_buff 。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>发送网络数据的时候，涉及几次内存拷贝操作？</p></blockquote>\n<p>第一次，调用发送数据的系统调用的时候，内核会申请一个内核态的 sk_buff 内存，将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区。</p>\n<p>第二次，在使用 TCP 传输协议的情况下，从传输层进入网络层的时候，每一个 sk_buff 都会被克隆一个新的副本出来。副本 sk_buff 会被送往网络层，等它发送完的时候就会释放掉，然后原始的 sk_buff 还保留在传输层，目的是为了实现 TCP 的可靠传输，等收到这个数据包的 ACK 时，才会释放原始的 sk_buff 。</p>\n<p>第三次，当 IP 层发现 sk_buff 大于 MTU 时才需要进行。会再申请额外的 sk_buff，并将原来的 sk_buff 拷贝为多个小的 sk_buff。</p>\n<h1 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h1><h2 id=\"HTTP-基本概念\"><a href=\"#HTTP-基本概念\" class=\"headerlink\" title=\"HTTP 基本概念\"></a>HTTP 基本概念</h2><p>HTTP 是超文本传输协议，也就是<strong>H</strong>yperText <strong>T</strong>ransfer <strong>P</strong>rotocol。</p>\n<h3 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h3><p>HTTP 是一个用在计算机世界里的<strong>协议</strong>。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（<strong>两个以上的参与者</strong>），以及相关的各种控制和错误处理方式（<strong>行为约定和规范</strong>）。</p>\n<h3 id=\"传输\"><a href=\"#传输\" class=\"headerlink\" title=\"传输\"></a>传输</h3><p>HTTP 协议是一个<strong>双向协议</strong>。而在 HTTP 里，需要中间人遵从 HTTP 协议，只要不打扰基本的数据传输，就可以添加任意额外的东西。</p>\n<p>针对<strong>传输</strong>，我们可以进一步理解了 HTTP。</p>\n<p>HTTP 是一个在计算机世界里专门用来在<strong>两点之间传输数据</strong>的约定和规范。</p>\n<h3 id=\"超文本\"><a href=\"#超文本\" class=\"headerlink\" title=\"超文本\"></a>超文本</h3><p>HTTP 传输的内容是「超文本」。</p>\n<p>我们先来理解「文本」，在互联网早期的时候只是简单的字符文字，但现在「文本」的涵义已经可以扩展为图片、视频、压缩包等，在 HTTP 眼里这些都算作「文本」。</p>\n<p>再来理解「超文本」，它就是<strong>超越了普通文本的文本</strong>，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。</p>\n<p>HTML 就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，再经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了。</p>\n<h2 id=\"HTTP-常见的状态码有哪些？\"><a href=\"#HTTP-常见的状态码有哪些？\" class=\"headerlink\" title=\"HTTP 常见的状态码有哪些？\"></a>HTTP 常见的状态码有哪些？</h2><p><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</p>\n<p><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p>\n<ul>\n<li>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li>\n<li>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li>\n<li>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li>\n</ul>\n<p><code>3xx</code> 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p>\n<ul>\n<li>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li>\n<li>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</li>\n</ul>\n<p>301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p>\n<ul>\n<li>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li>\n</ul>\n<p><code>4xx</code> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p>\n<ul>\n<li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li>\n<li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li>\n<li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li>\n</ul>\n<p><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p>\n<ul>\n<li>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li>\n<li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li>\n<li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li>\n<li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</li>\n</ul>\n<h2 id=\"HTTP-常见字段有哪些？\"><a href=\"#HTTP-常见字段有哪些？\" class=\"headerlink\" title=\"HTTP 常见字段有哪些？\"></a>HTTP 常见字段有哪些？</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>先贴一段我在开发中实际遇到的报文</p></blockquote>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\">2022-11-01 00:02:17.075083 [info]: POST /5 HTTP/1.1\n2022-11-01 00:02:17.075265 [info]: Host: localhost:9006\n2022-11-01 00:02:17.075102 [info]: adjust timer once\n2022-11-01 00:02:17.075408 [info]: Connection: keep-alive\n2022-11-01 00:02:17.075624 [info]: Content-Length: 0\n2022-11-01 00:02:17.075775 [info]: Cache-Control: max-age=0\n2022-11-01 00:02:17.076017 [info]: sec-ch-ua: \"Not?A_Brand\";v=\"8\", \"Chromium\";v=\"108\", \"Microsoft Edge\";v=\"108\"\n2022-11-01 00:02:17.076236 [info]: sec-ch-ua-mobile: ?0\n2022-11-01 00:02:17.076510 [info]: sec-ch-ua-platform: \"Linux\"\n2022-11-01 00:02:17.076842 [info]: Upgrade-Insecure-Requests: 1\n2022-11-01 00:02:17.077076 [info]: Origin: http://localhost:9006\n2022-11-01 00:02:17.077304 [info]: Content-Type: application/x-www-form-urlencoded\n2022-11-01 00:02:17.077492 [info]: User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36 Edg/108.0.1438.1\n2022-11-01 00:02:17.077731 [info]: Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\n2022-11-01 00:02:17.077977 [info]: Sec-Fetch-Site: same-origin\n2022-11-01 00:02:17.078187 [info]: Sec-Fetch-Mode: navigate\n2022-11-01 00:02:17.078396 [info]: Sec-Fetch-User: ?1\n2022-11-01 00:02:17.078630 [info]: Sec-Fetch-Dest: document\n2022-11-01 00:02:17.078890 [info]: Referer: http://localhost:9006/2CGISQL.cgi\n2022-11-01 00:02:17.079242 [info]: Accept-Encoding: gzip, deflate, br\n2022-11-01 00:02:17.079453 [info]: Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6\n2022-11-01 00:02:17.079747 [info]: \n2022-11-01 00:02:17.081606 [info]: request:HTTP/1.1 200 OK\n\n2022-11-01 00:02:17.081919 [info]: request:HTTP/1.1 200 OK\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Length</span><span class=\"token punctuation\">:</span><span class=\"token header-value\">340</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Connection</span><span class=\"token punctuation\">:</span><span class=\"token header-value\">keep-alive</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<ul>\n<li><p><em>Host</em> 字段：客户端发送请求时，用来指定服务器的域名。</p>\n</li>\n<li><p><em>Content-Length 字段</em>：服务器在返回数据时，会有 <code>Content-Length</code> 字段，表明本次回应的数据长度。</p>\n</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>大家应该都知道 HTTP 是基于 TCP 传输协议进行通信的，而使用了 TCP 传输协议，就会存在一个“粘包”的问题，<strong>HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题</strong>。</p></blockquote>\n<ul>\n<li><em>Connection 字段</em>：最常用于客户端要求服务器使用「 HTTP 长连接」机制，以便其他请求复用。</li>\n</ul>\n<p>HTTP&#x2F;1.1 版本的默认连接都是长连接，但为了兼容老版本的 HTTP，需要指定 <code>Connection</code> 首部字段的值为 <code>Keep-Alive</code>。(和上面的例子一样)</p>\n<ul>\n<li><em>Content-Type 字段</em>：用于服务器回应时，告诉客户端，本次数据是什么格式。</li>\n<li><em>Content-Encoding 字段</em>：说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式</li>\n</ul>\n<h2 id=\"GET-与-POST\"><a href=\"#GET-与-POST\" class=\"headerlink\" title=\"GET 与 POST\"></a>GET 与 POST</h2><p>根据 RFC 规范，<strong>GET 的语义是从服务器获取指定的资源</strong>，这个资源可以是静态的文本、页面、图片视频等。GET 请求的参数位置一般是写在 URL 中，URL 规定只能支持 ASCII，所以 GET 请求的参数只允许 ASCII 字符 ，而且浏览器会对 URL 的长度有限制（HTTP协议本身对 URL长度并没有做任何规定）。</p>\n<p>比如，你打开我的文章，浏览器就会发送 GET 请求给服务器，服务器就会返回文章的所有文字及资源。</p>\n<p>根据 RFC 规范，<strong>POST 的语义是根据请求负荷（报文body）对指定的资源做出处理</strong>，具体的处理方式视资源类型而不同。POST 请求携带数据的位置一般是写在报文 body 中， body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。</p>\n<p>比如，你在我文章底部，敲入了留言后点击「提交」（<strong>暗示你们留言</strong>），浏览器就会执行一次 POST 请求，把你的留言文字放进了报文 body 里，然后拼接好 POST 请求头，通过 TCP 协议发送给服务器。</p>\n<p>先说明下安全和幂等的概念：</p>\n<ul>\n<li>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</li>\n<li>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</li>\n</ul>\n<p>如果从 RFC 规范定义的语义来看：</p>\n<ul>\n<li><strong>GET 方法就是安全且幂等的</strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，<strong>可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签</strong>。</li>\n<li><strong>POST</strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。所以，<strong>浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签</strong>。</li>\n</ul>\n<p>做个简要的小结。</p>\n<p>GET 的语义是请求获取指定的资源。GET 方法是安全、幂等、可被缓存的。</p>\n<p>POST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST 不安全，不幂等，（大部分实现）不可缓存。</p>\n<h2 id=\"HTTP-缓存技术\"><a href=\"#HTTP-缓存技术\" class=\"headerlink\" title=\"HTTP 缓存技术\"></a>HTTP 缓存技术</h2><h3 id=\"强制缓存\"><a href=\"#强制缓存\" class=\"headerlink\" title=\"强制缓存\"></a>强制缓存</h3><p>强制缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。</p>\n<p>强制缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：</p>\n<ul>\n<li><code>Cache-Control</code>， 是一个相对时间；</li>\n<li><code>Expires</code>，是一个绝对时间；</li>\n</ul>\n<p>如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，<strong>Cache-Control的优先级高于 Expires</strong> 。</p>\n<p>Cache-control 选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存。具体的实现流程如下：</p>\n<ul>\n<li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；</li>\n<li>浏览器再次请求访问服务器中的该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</li>\n<li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</li>\n</ul>\n<h3 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h3><p>某些请求的响应码是 <code>304</code>，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。</p>\n<div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/缓存etag.2uza8w5bhqe0.webp\"/>\n</div>\n\n<p>协商缓存可以基于两种头部来实现。</p>\n<p>第一种：请求头部中的 <code>If-Modified-Since</code> 字段与响应头部中的 <code>Last-Modified</code> 字段实现，这两个字段的意思是：</p>\n<ul>\n<li>响应头部中的 <code>Last-Modified</code>：标示这个响应资源的最后修改时间；</li>\n<li>请求头部中的 <code>If-Modified-Since</code>：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。</li>\n</ul>\n<p>第二种：请求头部中的 <code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段，这两个字段的意思是：</p>\n<ul>\n<li>响应头部中 <code>Etag</code>：唯一标识响应资源；</li>\n<li>请求头部中的 <code>If-None-Match</code>：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。</li>\n</ul>\n<p>第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。</p>\n<p><strong>为什么 ETag 的优先级更高？</strong>这是因为 ETag 主要能解决 Last-Modified 几个比较难以解决的问题：</p>\n<ol>\n<li>在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致客户端认为这文件被改动了，从而重新请求；</li>\n<li>可能有些文件是在秒级以内修改的，<code>If-Modified-Since</code> 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次；</li>\n<li>有些服务器不能精确获取文件的最后修改时间。</li>\n</ol>\n<p>注意，<strong>协商缓存这两个字段都需要配合强制缓存中 Cache-control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</strong>。</p>\n<p>当使用 ETag 字段实现的协商缓存的过程：</p>\n<ul>\n<li><p>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；</p>\n</li>\n<li><p>当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：</p>\n<ul>\n<li>如果没有过期，则直接使用本地缓存；</li>\n<li>如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；</li>\n</ul>\n</li>\n<li><p>服务器再次收到请求后，</p>\n<p>会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较</p>\n<p>：</p>\n<ul>\n<li><strong>如果值相等，则返回 304 Not Modified，不会返回资源</strong>；</li>\n<li>如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；</li>\n</ul>\n</li>\n<li><p>如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。</p>\n</li>\n</ul>\n<h2 id=\"HTTP-特性\"><a href=\"#HTTP-特性\" class=\"headerlink\" title=\"HTTP 特性\"></a>HTTP 特性</h2><h3 id=\"HTTP-x2F-1-1-的优点\"><a href=\"#HTTP-x2F-1-1-的优点\" class=\"headerlink\" title=\"HTTP&#x2F;1.1 的优点\"></a>HTTP&#x2F;1.1 的优点</h3><p>HTTP 最凸出的优点是「简单、灵活和易于扩展、应用广泛和跨平台」。</p>\n<p><em>1. 简单</em></p>\n<p>HTTP 基本的报文格式就是 <code>header + body</code>，头部信息也是 <code>key-value</code> 简单文本的形式，<strong>易于理解</strong>，降低了学习和使用的门槛。</p>\n<p><em>2. 灵活和易于扩展</em></p>\n<p>HTTP 协议里的各类请求方法、URI&#x2F;URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员<strong>自定义和扩充</strong>。</p>\n<p>同时 HTTP 由于是工作在应用层（ <code>OSI</code> 第七层），则它<strong>下层可以随意变化</strong>，比如：</p>\n<ul>\n<li>HTTPS 就是在 HTTP 与 TCP 层之间增加了 SSL&#x2F;TLS 安全传输层；</li>\n<li>HTTP&#x2F;1.1 和 HTTP&#x2F;2.0 传输协议使用的是 TCP 协议，而到了 HTTP&#x2F;3.0 传输协议改用了 UDP 协议。</li>\n</ul>\n<p><em>3. 应用广泛和跨平台</em></p>\n<p>互联网发展至今，HTTP 的应用范围非常的广泛，从台式机的浏览器到手机上的各种 APP，从看新闻、刷贴吧到购物、理财、吃鸡，HTTP 的应用遍地开花，同时天然具有<strong>跨平台</strong>的优越性。</p>\n<h3 id=\"HTTP-x2F-1-1-的缺点\"><a href=\"#HTTP-x2F-1-1-的缺点\" class=\"headerlink\" title=\"HTTP&#x2F;1.1 的缺点\"></a>HTTP&#x2F;1.1 的缺点</h3><p><em>1. 无状态双刃剑</em></p>\n<p>无状态的<strong>好处</strong>，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。</p>\n<p>无状态的<strong>坏处</strong>，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。</p>\n<p>例如登录-&gt;添加购物车-&gt;下单-&gt;结算-&gt;支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。</p>\n<p>这样每操作一次，都要验证信息，这样的购物体验还能愉快吗？别问，问就是<strong>酸爽</strong>！</p>\n<p>对于无状态的问题，解法方案有很多种，其中比较简单的方式用 <strong>Cookie</strong> 技术。</p>\n<p><code>Cookie</code> 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</p>\n<p>相当于，*<em>在客户端第一次请求后，服务器会下发一个装有客户信息的「小贴纸」，后续客户端请求服务器的时候，带上「小贴纸」，服务器就能认得了了</em></p>\n<p><em>2. 明文传输双刃剑</em></p>\n<p>明文意味着在传输过程中的信息，是可方便阅读的，比如 Wireshark 抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性。</p>\n<p>但是这正是这样，HTTP 的所有信息都暴露在了光天化日下，相当于<strong>信息裸奔</strong>。在传输的漫长的过程中，信息的内容都毫无隐私可言，很容易就能被窃取，如果里面有你的账号密码信息，那<strong>你号没了</strong>。</p>\n<p><em>3. 不安全</em></p>\n<p>HTTP 比较严重的缺点就是不安全：</p>\n<ul>\n<li>通信使用明文（不加密），内容可能会被窃听。比如，<strong>账号信息容易泄漏，那你号没了。</strong></li>\n<li>不验证通信方的身份，因此有可能遭遇伪装。比如，<strong>访问假的淘宝、拼多多，那你钱没了。</strong></li>\n<li>无法证明报文的完整性，所以有可能已遭篡改。比如，<strong>网页上植入垃圾广告，视觉污染，眼没了。</strong></li>\n</ul>\n<p>HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL&#x2F;TLS 层，使得在安全上达到了极致。</p>\n<h3 id=\"HTTP-x2F-1-1-的性能\"><a href=\"#HTTP-x2F-1-1-的性能\" class=\"headerlink\" title=\"HTTP&#x2F;1.1 的性能\"></a>HTTP&#x2F;1.1 的性能</h3><p><em>1. 长连接</em></p>\n<p>早期 HTTP&#x2F;1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。</p>\n<p>为了解决上述 TCP 连接问题，HTTP&#x2F;1.1 提出了<strong>长连接</strong>的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</p>\n<p>持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p>\n<p><em>2. 管道网络传输</em></p>\n<p>HTTP&#x2F;1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。</p>\n<p>即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以<strong>减少整体的响应时间。</strong></p>\n<p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。那么，管道机制则是允许浏览器同时发出 A 请求和 B 请求，</p>\n<p>但是<strong>服务器必须按照接收请求的顺序发送对这些管道化请求的响应</strong>。</p>\n<p>如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为「队头堵塞」。</p>\n<p>所以，<strong>HTTP&#x2F;1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞</strong>。</p>\n<p><em>3. 队头阻塞</em></p>\n<p>「请求 - 应答」的模式加剧了 HTTP 的性能问题。</p>\n<p>因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「<strong>队头阻塞</strong>」，好比上班的路上塞车。</p>\n<h2 id=\"HTTP-与-HTTPS\"><a href=\"#HTTP-与-HTTPS\" class=\"headerlink\" title=\"HTTP 与 HTTPS\"></a>HTTP 与 HTTPS</h2><h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><ul>\n<li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</li>\n<li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li>\n<li>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li>\n<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li>\n</ul>\n<h3 id=\"HTTPS优化\"><a href=\"#HTTPS优化\" class=\"headerlink\" title=\"HTTPS优化\"></a>HTTPS优化</h3><p>HTTP 由于是明文传输，所以安全上存在以下三个风险：</p>\n<ul>\n<li><strong>窃听风险</strong>，比如通信链路上可以获取通信内容，用户号容易没。</li>\n<li><strong>篡改风险</strong>，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。</li>\n<li><strong>冒充风险</strong>，比如冒充淘宝网站，用户钱容易没。</li>\n</ul>\n<p>HTTP<strong>S</strong> 在 HTTP 与 TCP 层之间加入了 <code>SSL/TLS</code> 协议，可以很好的解决了上述的风险：</p>\n<ul>\n<li><strong>信息加密</strong>：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。</li>\n<li><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。</li>\n<li><strong>身份证书</strong>：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。</li>\n</ul>\n<p>可见，只要自身不做「恶」，SSL&#x2F;TLS 协议是能保证通信是安全的</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>HTTPS 是如何解决上面的三个风险的？</p></blockquote>\n<ul>\n<li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。</li>\n<li><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</li>\n<li>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险</li>\n</ul>\n<p><em>1. 混合加密</em></p>\n<p>通过<strong>混合加密</strong>的方式可以保证信息的<strong>机密性</strong>，解决了窃听的风险。</p>\n<p>HTTPS 采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的「混合加密」方式：</p>\n<ul>\n<li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。</li>\n<li>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</li>\n</ul>\n<p>采用「混合加密」的方式的原因：</p>\n<ul>\n<li><strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li>\n<li><strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li>\n</ul>\n<p><em>2. 摘要算法 + 数字签名</em></p>\n<p>为了保证传输的内容不被篡改，我们需要对内容计算出一个「指纹」，然后同内容一起传输给对方。</p>\n<p>对方收到后，先是对内容也计算出一个「指纹」，然后跟发送方发送的「指纹」做一个比较，如果「指纹」相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。</p>\n<p>那么，在计算机里会<strong>用摘要算法（哈希函数）来计算出内容的哈希值</strong>，也就是内容的「指纹」，这个<strong>哈希值是唯一的，且无法通过哈希值推导出内容</strong>。</p>\n<p>通过哈希算法可以确保内容不会被篡改，<strong>但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明</strong>。</p>\n<p>举个例子，你想向老师请假，一般来说是要求由家长写一份请假理由并签名，老师才能允许你请假。</p>\n<p>但是你有模仿你爸爸字迹的能力，你用你爸爸的字迹写了一份请假理由然后签上你爸爸的名字，老师一看到这个请假条，查看字迹和签名，就误以为是你爸爸写的，就会允许你请假。</p>\n<p>那作为老师，要如何避免这种情况发生呢？现实生活中的，可以通过电话或视频来确认是否是由父母发出的请假，但是计算机里可没有这种操作。</p>\n<p>那为了避免这种情况，计算机里会用<strong>非对称加密算法</strong>来解决，共有两个密钥：</p>\n<ul>\n<li>一个是公钥，这个是可以公开给所有人的；</li>\n<li>一个是私钥，这个必须由本人管理，不可泄露。</li>\n</ul>\n<p>这两个密钥可以<strong>双向加解密</strong>的，比如可以用公钥加密内容，然后用私钥解密，也可以用私钥加密内容，公钥解密内容。</p>\n<p>流程的不同，意味着目的也不相同：</p>\n<ul>\n<li><strong>公钥加密，私钥解密</strong>。这个目的是为了<strong>保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；</li>\n<li><strong>私钥加密，公钥解密</strong>。这个目的是为了<strong>保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。</li>\n</ul>\n<p>一般我们不会用非对称加密来加密实际的传输内容，因为非对称加密的计算比较耗费性能的。</p>\n<p>所以非对称加密的用途主要在于<strong>通过「私钥加密，公钥解密」的方式，来确认消息的身份</strong>，我们常说的<strong>数字签名算法</strong>，就是用的是这种方式，不过私钥加密内容不是内容本身，而是<strong>对内容的哈希值加密</strong>。</p>\n<div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/数字签名.4qp5kryyb4i0.webp\"/>\n</div>\n\n<p><em>3. 数字证书</em></p>\n<p>前面我们知道：</p>\n<ul>\n<li>可以通过哈希算法来保证消息的完整性；</li>\n<li>可以通过数字签名来保证消息的来源可靠性（能确认消息是由持有私钥的一方发送的）；</li>\n</ul>\n<p>通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。</p>\n<h3 id=\"HTTPS-是如何建立连接\"><a href=\"#HTTPS-是如何建立连接\" class=\"headerlink\" title=\"HTTPS 是如何建立连接\"></a>HTTPS 是如何建立连接</h3><p>SSL&#x2F;TLS 协议基本流程：</p>\n<ul>\n<li>客户端向服务器索要并验证服务器的公钥。</li>\n<li>双方协商生产「会话秘钥」。</li>\n<li>双方采用「会话秘钥」进行加密通信。</li>\n</ul>\n<p>前两步也就是 SSL&#x2F;TLS 的建立过程，也就是 TLS 握手阶段。</p>\n<p>TLS 的「握手阶段」涉及<strong>四次</strong>通信，使用不同的密钥交换算法，TLS 握手流程也会不一样的，现在常用的密钥交换算法有两种：<a href=\"https://xiaolincoding.com/network/2_http/https_rsa.html\">RSA 算法 </a>和 <a href=\"https://xiaolincoding.com/network/2_http/https_ecdhe.html\">ECDHE 算法 </a>。</p>\n<p>基于 RSA 算法的 TLS 握手过程比较容易理解，所以这里先用这个给大家展示 TLS 握手过程，如下图：</p>\n<div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/23-HTTPS工作流程.gtdfk48cagw.webp\"/>\n</div>\n\n<p><em>1. ClientHello</em></p>\n<p>首先，由客户端向服务器发起加密通信请求，也就是 <code>ClientHello</code> 请求。</p>\n<p>在这一步，客户端主要向服务器发送以下信息：</p>\n<p>（1）客户端支持的 TLS 协议版本，如 TLS 1.2 版本。</p>\n<p>（2）客户端生产的随机数（<code>Client Random</code>），后面用于生成「会话秘钥」条件之一。</p>\n<p>（3）客户端支持的密码套件列表，如 RSA 加密算法。</p>\n<p><em>2. SeverHello</em></p>\n<p>服务器收到客户端请求后，向客户端发出响应，也就是 <code>SeverHello</code>。服务器回应的内容有如下内容：</p>\n<p>（1）确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。</p>\n<p>（2）服务器生产的随机数（<code>Server Random</code>），也是后面用于生产「会话秘钥」条件之一。</p>\n<p>（3）确认的密码套件列表，如 RSA 加密算法。</p>\n<p>（4）服务器的数字证书。</p>\n<p><em>3.客户端回应</em></p>\n<p>客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。</p>\n<p>如果证书没有问题，客户端会<strong>从数字证书中取出服务器的公钥</strong>，然后使用它加密报文，向服务器发送如下信息：</p>\n<p>（1）一个随机数（<code>pre-master key</code>）。该随机数会被服务器公钥加密。</p>\n<p>（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p>\n<p>（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</p>\n<p>上面第一项的随机数是整个握手阶段的第三个随机数，会发给服务端，所以这个随机数客户端和服务端都是一样的。</p>\n<p><strong>服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」</strong>。</p>\n<p><em>4. 服务器的最后回应</em></p>\n<p>服务器收到客户端的第三个随机数（<code>pre-master key</code>）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。</p>\n<p>然后，向客户端发送最后的信息：</p>\n<p>（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p>\n<p>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</p>\n<p>至此，整个 TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。</p>\n<h4 id=\"客户端校验数字证书的流程\"><a href=\"#客户端校验数字证书的流程\" class=\"headerlink\" title=\"客户端校验数字证书的流程\"></a>客户端校验数字证书的流程</h4><div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/证书的校验.4icjlflylp20.webp\"/>\n</div>\n\n<p>CA 签发证书的过程，如上图左边部分：</p>\n<ul>\n<li>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</li>\n<li>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</li>\n<li>最后将 Certificate Signature 添加在文件证书上，形成数字证书；</li>\n</ul>\n<p>客户端校验服务端的数字证书的过程，如上图右边部分：</p>\n<ul>\n<li>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</li>\n<li>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；</li>\n<li>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</li>\n</ul>\n<p>但事实上，证书的验证过程中<strong>还存在一个证书信任链的问题</strong>，因为我们向 CA 申请的证书一般不是根证书签发的，而是由中间证书签发的，比如百度的证书，从下图你可以看到，证书的层级有三级：</p>\n<p>对于这种三级层级关系的证书的验证过程如下：</p>\n<ul>\n<li>客户端收到 baidu.com 的证书后，发现这个证书的签发者不是根证书，就无法根据本地已有的根证书中的公钥去验证 baidu.com 证书是否可信。于是，客户端根据 baidu.com 证书中的签发者，找到该证书的颁发机构是 “GlobalSign Organization Validation CA - SHA256 - G2”，然后向 CA 请求该中间证书。</li>\n<li>请求到证书后发现 “GlobalSign Organization Validation CA - SHA256 - G2” 证书是由 “GlobalSign Root CA” 签发的，由于 “GlobalSign Root CA” 没有再上级签发机构，说明它是根证书，也就是自签证书。应用软件会检查此证书有否已预载于根证书清单上，如果有，则可以利用根证书中的公钥去验证 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，如果发现验证通过，就认为该中间证书是可信的。</li>\n<li>“GlobalSign Organization Validation CA - SHA256 - G2” 证书被信任后，可以使用 “GlobalSign Organization Validation CA - SHA256 - G2” 证书中的公钥去验证 baidu.com 证书的可信性，如果验证通过，就可以信任 baidu.com 证书。</li>\n</ul>\n<p>在这四个步骤中，最开始客户端只信任根证书 GlobalSign Root CA 证书的，然后 “GlobalSign Root CA” 证书信任 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，而 “GlobalSign Organization Validation CA - SHA256 - G2” 证书又信任 baidu.com 证书，于是客户端也信任 baidu.com 证书。</p>\n<p>总括来说，由于用户信任 GlobalSign，所以由 GlobalSign 所担保的 baidu.com 可以被信任，另外由于用户信任操作系统或浏览器的软件商，所以由软件商预载了根证书的 GlobalSign 都可被信任。</p>\n<p><strong>这是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题。</strong></p>\n<h3 id=\"HTTPS-的应用数据如何保证完整性\"><a href=\"#HTTPS-的应用数据如何保证完整性\" class=\"headerlink\" title=\"HTTPS 的应用数据如何保证完整性\"></a>HTTPS 的应用数据如何保证完整性</h3><p>TLS 在实现上分为<strong>握手协议</strong>和<strong>记录协议</strong>两层：</p>\n<ul>\n<li>TLS 握手协议就是我们前面说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）；</li>\n<li>TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；</li>\n</ul>\n<p>TLS 记录协议主要负责消息（HTTP 数据）的压缩，加密及数据的认证，过程如下图：</p>\n<p>具体过程如下：</p>\n<ul>\n<li>首先，消息被分割成多个较短的片段,然后分别对每个片段进行压缩。</li>\n<li>接下来，经过压缩的片段会被<strong>加上消息认证码（MAC 值，这个是通过哈希算法生成的），这是为了保证完整性，并进行数据的认证</strong>。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编码。</li>\n<li>再接下来，经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。</li>\n<li>最后，上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。</li>\n</ul>\n<p>记录协议完成后，最终的报文数据将传递到传输控制协议 (TCP) 层进行传输。<a href=\"https://blog.csdn.net/zhanyiwp/article/details/105627799\">理解SSL&#x2F;TLS系列 (四) 记录协议</a></p>\n<h3 id=\"HTTPS-一定安全可靠\"><a href=\"#HTTPS-一定安全可靠\" class=\"headerlink\" title=\"HTTPS 一定安全可靠\"></a>HTTPS 一定安全可靠</h3><p>客户端通过浏览器向服务端发起 HTTPS 请求时，被「假基站」转发到了一个「中间人服务器」，于是客户端是和「中间人服务器」完成了 TLS 握手，然后这个「中间人服务器」再与真正的服务端完成 TLS 握手。</p>\n<p>具体过程如下：</p>\n<ul>\n<li>客户端向服务端发起 HTTPS 建立连接请求时，然后被「假基站」转发到了一个「中间人服务器」，接着中间人向服务端发起 HTTPS 建立连接请求，此时客户端与中间人进行 TLS 握手，中间人与服务端进行 TLS 握手；</li>\n<li>在客户端与中间人进行 TLS 握手过程中，中间人会发送自己的公钥证书给客户端，<strong>客户端验证证书的真伪</strong>，然后从证书拿到公钥，并生成一个随机数，用公钥加密随机数发送给中间人，中间人使用私钥解密，得到随机数，此时双方都有随机数，然后通过算法生成对称加密密钥（A），后续客户端与中间人通信就用这个对称加密密钥来加密数据了。</li>\n<li>在中间人与服务端进行 TLS 握手过程中，服务端会发送从 CA 机构签发的公钥证书给中间人，从证书拿到公钥，并生成一个随机数，用公钥加密随机数发送给服务端，服务端使用私钥解密，得到随机数，此时双方都有随机数，然后通过算法生成对称加密密钥（B），后续中间人与服务端通信就用这个对称加密密钥来加密数据了。</li>\n<li>后续的通信过程中，中间人用对称加密密钥（A）解密客户端的 HTTPS 请求的数据，然后用对称加密密钥（B）加密 HTTPS 请求后，转发给服务端，接着服务端发送 HTTPS 响应数据给中间人，中间人用对称加密密钥（B）解密 HTTPS 响应数据，然后再用对称加密密钥（A）加密后，转发给客户端。</li>\n</ul>\n<p>从客户端的角度看，其实并不知道网络中存在中间人服务器这个角色。那么中间人就可以解开浏览器发起的 HTTPS 请求里的数据，也可以解开服务端响应给浏览器的 HTTPS 响应数据。相当于，中间人能够 “偷看” 浏览器与服务端之间的 HTTPS 请求和响应的数据。</p>\n<p>但是要发生这种场景是有前提的，前提是用户点击接受了中间人服务器的证书。</p>\n<p>中间人服务器与客户端在 TLS 握手过程中，实际上发送了自己伪造的证书给浏览器，而这个伪造的证书是能被浏览器（客户端）识别出是非法的，于是就会提醒用户该证书存在问题。</p>\n<p>如果用户执意点击「继续浏览此网站」，相当于用户接受了中间人伪造的证书，那么后续整个 HTTPS 通信都能被中间人监听了。</p>\n<p>所以，这其实并不能说 HTTPS 不够安全，毕竟浏览器都已经提示证书有问题了，如果用户坚决要访问，那不能怪 HTTPS ，得怪自己手贱。</p>\n<p>另外，如果你的电脑中毒了，被恶意导入了中间人的根证书，那么在验证中间人的证书的时候，由于你操作系统信任了中间人的根证书，那么等同于中间人的证书是合法的，这种情况下，浏览器是不会弹出证书存在问题的风险提醒的。</p>\n<p>这其实也不关 HTTPS 的事情，是你电脑中毒了才导致 HTTPS 数据被中间人劫持的。</p>\n<p>所以，<strong>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全</strong>。</p>\n<p>我们还可以通过 <strong>HTTPS 双向认证</strong>来避免这种问题。</p>\n<p>一般我们的 HTTPS 是单向认证，客户端只会验证了服务端的身份，但是服务端并不会验证客户端的身份。</p>\n<p>如果用了双向认证方式，不仅客户端会验证服务端的身份，而且服务端也会验证客户端的身份。服务端一旦验证到请求自己的客户端为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。</p>\n<div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/双向认证.6efpgku0xfs0.webp\"/>\n</div>\n\n<h2 id=\"HTTP-x2F-1-1、HTTP-x2F-2、HTTP-x2F-3-演变\"><a href=\"#HTTP-x2F-1-1、HTTP-x2F-2、HTTP-x2F-3-演变\" class=\"headerlink\" title=\"HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变\"></a>HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变</h2><h3 id=\"HTTP-x2F-1-1-相比-HTTP-x2F-1-0-提高了什么性能？\"><a href=\"#HTTP-x2F-1-1-相比-HTTP-x2F-1-0-提高了什么性能？\" class=\"headerlink\" title=\"HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能？\"></a>HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能？</h3><p>HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 性能上的改进：</p>\n<ul>\n<li>使用长连接的方式改善了 HTTP&#x2F;1.0 短连接造成的性能开销。</li>\n<li>支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li>\n</ul>\n<p>但 HTTP&#x2F;1.1 还是有性能瓶颈：</p>\n<ul>\n<li>请求 &#x2F; 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 <code>Body</code> 的部分；</li>\n<li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</li>\n<li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；</li>\n<li>没有请求优先级控制；</li>\n<li>请求只能从客户端开始，服务器只能被动响应。</li>\n</ul>\n<h3 id=\"HTTP-x2F-2-做了什么优化？\"><a href=\"#HTTP-x2F-2-做了什么优化？\" class=\"headerlink\" title=\"HTTP&#x2F;2 做了什么优化？\"></a>HTTP&#x2F;2 做了什么优化？</h3><p>HTTP&#x2F;2 协议是基于 HTTPS 的，所以 HTTP&#x2F;2 的安全性也是有保障的。</p>\n<div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/25-HTTP2.3b8r2341b6o0.webp\"/>\n</div>\n\n<p>那 HTTP&#x2F;2 相比 HTTP&#x2F;1.1 性能上的改进：</p>\n<ul>\n<li>头部压缩</li>\n<li>二进制格式</li>\n<li>并发传输</li>\n<li>服务器主动推送资源</li>\n</ul>\n<p><em>1. 头部压缩</em></p>\n<p>HTTP&#x2F;2 会<strong>压缩头</strong>（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的部分</strong>。</p>\n<p>这就是所谓的 <code>HPACK</code> 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就<strong>提高速度</strong>了。</p>\n<p><em>2. 二进制格式</em></p>\n<p>HTTP&#x2F;2 不再像 HTTP&#x2F;1.1 里的纯文本形式的报文，而是全面采用了<strong>二进制格式</strong>，头信息和数据体都是二进制，并且统称为帧（frame）：<strong>头信息帧（Headers Frame）和数据帧（Data Frame）</strong>。</p>\n<p>这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这<strong>增加了数据传输的效率</strong>。</p>\n<p>比如状态码 200 ，在 HTTP&#x2F;1.1 是用 ‘2’’0’’0’ 三个字符来表示（二进制：00110010 00110000 00110000），共用了 3 个字节。</p>\n<p>在 HTTP&#x2F;2 对于状态码 200 的二进制编码是 10001000，只用了 1 字节就能表示，相比于 HTTP&#x2F;1.1 节省了 2 个字节</p>\n<ol>\n<li>最前面的 1 标识该 Header 是静态表中已经存在的 KV。</li>\n<li>在静态表理，“:status: 200 ok” 静态表编码是 8，二进制即是 1000。</li>\n</ol>\n<p>因此，整体加起来就是 1000 1000。</p>\n<p><em>3. 并发传输</em></p>\n<p>我们都知道 HTTP&#x2F;1.1 的实现是基于请求-响应模型的。同一个连接中，HTTP 完成一个事务（请求与响应），才能处理下一个事务，也就是说在发出请求等待响应的过程中，是没办法做其他事情的，如果响应迟迟不来，那么后续的请求是无法发送的，也造成了<strong>队头阻塞</strong>的问题。</p>\n<p>而 HTTP&#x2F;2 就很牛逼了，引出了 Stream 概念，多个 Stream 复用在一条 TCP 连接。</p>\n<div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/stream.2wafkvfpsv0.webp\"/>\n</div>\n\n<p>从上图可以看到，1 个 TCP 连接包含多个 Stream，Stream 里可以包含 1 个或多个 Message，Message 对应 HTTP&#x2F;1 中的请求或响应，由 HTTP 头部和包体构成。Message 里包含一条或者多个 Frame，Frame 是 HTTP&#x2F;2 最小单位，以二进制压缩格式存放 HTTP&#x2F;1 中的内容（头部和包体）。</p>\n<p><strong>针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP&#x2F;2 可以并行交错地发送请求和响应</strong>。</p>\n<p>比如下图，服务端<strong>并行交错地</strong>发送了两个响应： Stream 1 和 Stream 3，这两个 Stream 都是跑在一个 TCP 连接上，客户端收到后，会根据相同的 Stream ID 有序组装成 HTTP 消息。</p>\n<p><em>4、服务器推送</em></p>\n<p>HTTP&#x2F;2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务端不再是被动地响应，可以<strong>主动</strong>向客户端发送消息。</p>\n<p>客户端和服务器<strong>双方都可以建立 Stream</strong>， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。</p>\n<p>再比如，客户端通过 HTTP&#x2F;1.1 请求从服务器那获取到了 HTML 文件，而 HTML 可能还需要依赖 CSS 来渲染页面，这时客户端还要再发起获取 CSS 文件的请求，需要两次消息往返，在 HTTP&#x2F;2 中，客户端在访问 HTML 时，服务器可以直接主动推送 CSS 文件，减少了消息传递的次数。</p>\n<h3 id=\"HTTP-x2F-2-有什么缺陷？\"><a href=\"#HTTP-x2F-2-有什么缺陷？\" class=\"headerlink\" title=\"HTTP&#x2F;2 有什么缺陷？\"></a>HTTP&#x2F;2 有什么缺陷？</h3><p>HTTP&#x2F;2 通过 Stream 的并发能力，解决了 HTTP&#x2F;1 队头阻塞的问题，看似很完美了，但是 HTTP&#x2F;2 还是存在“队头阻塞”的问题，只不过问题不是在 HTTP 这一层面，而是在 TCP 这一层。</p>\n<p><strong>HTTP&#x2F;2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP&#x2F;2 应用层才能从内核中拿到数据，这就是 HTTP&#x2F;2 队头阻塞问题。</strong></p>\n<h3 id=\"HTTP-x2F-3-做了哪些优化？\"><a href=\"#HTTP-x2F-3-做了哪些优化？\" class=\"headerlink\" title=\"HTTP&#x2F;3 做了哪些优化？\"></a>HTTP&#x2F;3 做了哪些优化？</h3><p>一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的<strong>所有的 HTTP 请求都必须等待这个丢了的包被重传回来</strong>。</p>\n<p>前面我们知道了 HTTP&#x2F;1.1 和 HTTP&#x2F;2 都有队头阻塞的问题：</p>\n<ul>\n<li>HTTP&#x2F;1.1 中的管道（ pipeline）虽然解决了请求的队头阻塞，但是<strong>没有解决响应的队头阻塞</strong>，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等响应完这个请求后， 才能处理下一个请求，这属于 HTTP 层队头阻塞。</li>\n<li>HTTP&#x2F;2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是<strong>一旦发生丢包，就会阻塞住所有的 HTTP 请求</strong>，这属于 TCP 层队头阻塞。</li>\n</ul>\n<p>HTTP&#x2F;2 队头阻塞的问题是因为 TCP，所以 <strong>HTTP&#x2F;3 把 HTTP 下层的 TCP 协议改成了 UDP！</strong></p>\n<div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/27-HTTP3.5l5uhpmazdw0.webp\"/>\n</div>\n\n<p>UDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP&#x2F;2 队头阻塞的问题。大家都知道 UDP 是不可靠传输的，但基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输。</p>\n<p>QUIC 有以下 3 个特点。</p>\n<ul>\n<li>无队头阻塞</li>\n<li>更快的连接建立</li>\n<li>连接迁移</li>\n</ul>\n<p><em>1、无队头阻塞</em></p>\n<p>QUIC 协议也有类似 HTTP&#x2F;2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。</p>\n<p>QUIC 有自己的一套机制可以保证传输的可靠性的。<strong>当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题</strong>。这与 HTTP&#x2F;2 不同，HTTP&#x2F;2 只要某个流中的数据包丢失了，其他流也会因此受影响。</p>\n<p>所以，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。</p>\n<p><em>2、更快的连接建立</em></p>\n<p>对于 HTTP&#x2F;1 和 HTTP&#x2F;2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。</p>\n<p>HTTP&#x2F;3 在传输数据前虽然需要 QUIC 协议握手，这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。</p>\n<p>但是 HTTP&#x2F;3 的 QUIC 协议并不是与 TLS 分层，而是QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS&#x2F;1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商</p>\n<p><em>3、连接迁移</em></p>\n<p>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。</p>\n<p>那么<strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接</strong>。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p>\n<p>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong>来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p>\n<p>所以， QUIC 是一个在 UDP 之上的<strong>伪</strong> TCP + TLS + HTTP&#x2F;2 的多路复用的协议。</p>\n<p>QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题，因为有的网络设备是会丢掉 UDP 包的，而 QUIC 是基于UDP 实现的，那么如果网络设备无法识别这个是 QUIC 包，那么就会当作 UDP包，然后被丢弃。</p>\n<p>HTTP&#x2F;3 现在普及的进度非常的缓慢，不知道未来 UDP 是否能够逆袭 TCP。</p>\n<h2 id=\"HTTP-x2F-1-1如何优化\"><a href=\"#HTTP-x2F-1-1如何优化\" class=\"headerlink\" title=\"HTTP&#x2F;1.1如何优化\"></a>HTTP&#x2F;1.1如何优化</h2><ul>\n<li><em>尽量避免发送 HTTP 请求</em>；</li>\n<li><em>在需要发送 HTTP 请求时，考虑如何减少请求次数</em>；</li>\n<li><em>减少服务器的 HTTP 响应的数据大小</em>；</li>\n</ul>\n<h3 id=\"如何避免发送-HTTP-请求？\"><a href=\"#如何避免发送-HTTP-请求？\" class=\"headerlink\" title=\"如何避免发送 HTTP 请求？\"></a>如何避免发送 HTTP 请求？</h3><p>所以，避免发送 HTTP 请求的方法就是通过<strong>缓存技术</strong>，HTTP 设计者早在之前就考虑到了这点，因此 HTTP 协议的头部有不少是针对缓存的字段。</p>\n<p>那缓存是如何做到的呢？</p>\n<p>客户端会把第一次请求以及响应的数据保存在本地磁盘上，其中将请求的 URL 作为 key，而响应作为 value，两者形成映射关系。</p>\n<p>这样当后续发起相同的请求时，就可以先在本地磁盘上通过 key 查到对应的 value，也就是响应，如果找到了，就直接从本地读取该响应。</p>\n<p>服务器在发送 HTTP 响应时，会估算一个过期的时间，并把这个信息放到响应头部中，这样客户端在查看响应头部的信息时，一旦发现缓存的响应是过期的，则就会重新发送网络请求。</p>\n<p>如果客户端从第一次请求得到的响应头部中发现该响应过期了，客户端重新发送请求，假设服务器上的资源并没有变更，还是老样子，那么你觉得还要在服务器的响应带上这个资源吗？</p>\n<p>很显然不带的话，可以提高 HTTP 协议的性能，那具体如何做到呢？</p>\n<p>只需要客户端在重新发送请求时，在请求的 <code>Etag</code> 头部带上第一次请求的响应头部中的摘要，这个摘要是唯一标识响应的资源，当服务器收到请求后，会将本地资源的摘要与请求中的摘要做个比较。</p>\n<p>如果不同，那么说明客户端的缓存已经没有价值，服务器在响应中带上最新的资源。</p>\n<p>如果相同，说明客户端的缓存还是可以继续使用的，那么服务器<strong>仅返回不含有包体的 <code>304 Not Modified</code> 响应</strong>，告诉客户端仍然有效，这样就可以减少响应资源在网络中传输的延时</p>\n<h3 id=\"如何减少-HTTP-请求次数？\"><a href=\"#如何减少-HTTP-请求次数？\" class=\"headerlink\" title=\"如何减少 HTTP 请求次数？\"></a>如何减少 HTTP 请求次数？</h3><p>减少 HTTP 请求次数自然也就提升了 HTTP 性能，可以从这 3 个方面入手：</p>\n<ul>\n<li><em>减少重定向请求次数</em>；</li>\n<li><em>合并请求</em>；</li>\n<li><em>延迟发送请求</em>；</li>\n</ul>\n<h4 id=\"减少重定向请求次数\"><a href=\"#减少重定向请求次数\" class=\"headerlink\" title=\"减少重定向请求次数\"></a>减少重定向请求次数</h4><p>我们先来看看什么是<strong>重定向请求</strong>？</p>\n<p>服务器上的一个资源可能由于迁移、维护等原因从 url1 移至 url2 后，而客户端不知情，它还是继续请求 url1，这时服务器不能粗暴地返回错误，而是通过 <code>302</code> 响应码和 <code>Location</code> 头部，告诉客户端该资源已经迁移至 url2 了，于是客户端需要再发送 url2 请求以获得服务器的资源。</p>\n<p>那么，如果重定向请求越多，那么客户端就要多次发起 HTTP 请求，每一次的 HTTP 请求都得经过网络，这无疑会越降低网络性能。</p>\n<p>另外，服务端这一方往往不只有一台服务器，比如源服务器上一级是代理服务器，然后代理服务器才与客户端通信，这时客户端重定向就会导致客户端与代理服务器之间需要 2 次消息传递。</p>\n<p>如果<strong>重定向的工作交由代理服务器完成，就能减少 HTTP 请求次数了</strong>。</p>\n<p>而且当代理服务器知晓了重定向规则后，可以进一步减少消息传递次数。</p>\n<p>除了 <code>302</code> 重定向响应码，还有其他一些重定向的响应码，你可以从下图看到：</p>\n<div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/重定向响应码.1mwmvu6osoow.webp\"/>\n</div>\n\n<p>其中，<code>301</code> 和 <code>308</code> 响应码是告诉客户端可以将重定向响应缓存到本地磁盘，之后客户端就自动用 url2 替代 url1 访问服务器的资源。</p>\n<h4 id=\"合并请求\"><a href=\"#合并请求\" class=\"headerlink\" title=\"合并请求\"></a>合并请求</h4><p>如果把多个访问小文件的请求合并成一个大的请求，虽然传输的总资源还是一样，但是减少请求，也就意味着<strong>减少了重复发送的 HTTP 头部</strong>。</p>\n<p>另外由于 HTTP&#x2F;1.1 是请求响应模型，如果第一个发送的请求，未收到对应的响应，那么后续的请求就不会发送（PS：HTTP&#x2F;1.1 管道模式是默认不使用的，所以讨论 HTTP&#x2F;1.1 的队头阻塞问题，是不考虑管道模式的），于是为了防止单个请求的阻塞，所以<strong>一般浏览器会同时发起 5-6 个请求，每一个请求都是不同的 TCP 连接</strong>，那么如果合并了请求，也就会<strong>减少 TCP 连接的数量，因而省去了 TCP 握手和慢启动过程耗费的时间</strong>。</p>\n<p>接下来，具体看看合并请求的几种方式。</p>\n<p>有的网页会含有很多小图片、小图标，有多少个小图片，客户端就要发起多少次请求。那么对于这些小图片，我们可以考虑使用 <code>CSS Image Sprites</code> 技术把它们合成一个大图片，这样浏览器就可以用一次请求获得一个大图片，然后再根据 CSS 数据把大图片切割成多张小图片。</p>\n<p>这种方式就是<strong>通过将多个小图片合并成一个大图片来减少 HTTP 请求的次数，以减少 HTTP 请求的次数，从而减少网络的开销</strong>。</p>\n<p>除了将小图片合并成大图片的方式，还有服务端使用 <code>webpack</code> 等打包工具将 js、css 等资源合并打包成大文件，也是能达到类似的效果。</p>\n<p>另外，还可以将图片的二进制数据用 <code>base64</code> 编码后，以 URL 的形式嵌入到 HTML 文件，跟随 HTML 文件一并发送.</p>\n<p>可以看到，<strong>合并请求的方式就是合并资源，以一个大资源的请求替换多个小资源的请求</strong>。</p>\n<p>但是这样的合并请求会带来新的问题，<strong>当大资源中的某一个小资源发生变化后，客户端必须重新下载整个完整的大资源文件</strong>，这显然带来了额外的网络消耗。</p>\n<h4 id=\"延迟发送请求\"><a href=\"#延迟发送请求\" class=\"headerlink\" title=\"延迟发送请求\"></a>延迟发送请求</h4><p>不要一口气吃成大胖子，一般 HTML 里会含有很多 HTTP 的 URL，当前不需要的资源，我们没必要也获取过来，于是可以通过「<strong>按需获取</strong>」的方式，来减少第一时间的 HTTP 请求次数。</p>\n<p>请求网页的时候，没必要把全部资源都获取到，而是只获取当前用户所看到的页面资源，当用户向下滑动页面的时候，再向服务器获取接下来的资源，这样就达到了延迟发送请求的效果。</p>\n<h3 id=\"如何减少-HTTP-响应的数据大小？\"><a href=\"#如何减少-HTTP-响应的数据大小？\" class=\"headerlink\" title=\"如何减少 HTTP 响应的数据大小？\"></a>如何减少 HTTP 响应的数据大小？</h3><p>对于 HTTP 的请求和响应，通常 HTTP 的响应的数据大小会比较大，也就是服务器返回的资源会比较大。</p>\n<p>于是，我们可以考虑对响应的资源进行<strong>压缩</strong>，这样就可以减少响应的数据大小，从而提高网络传输的效率。</p>\n<p>压缩的方式一般分为 2 种，分别是：</p>\n<ul>\n<li><em>无损压缩</em>；</li>\n<li><em>有损压缩</em>；</li>\n</ul>\n<h4 id=\"无损压缩\"><a href=\"#无损压缩\" class=\"headerlink\" title=\"无损压缩\"></a>无损压缩</h4><p>无损压缩是指资源经过压缩后，信息不被破坏，还能完全恢复到压缩前的原样，适合用在文本文件、程序可执行文件、程序源代码。</p>\n<p>首先，我们针对代码的语法规则进行压缩，因为通常代码文件都有很多换行符或者空格，这些是为了帮助程序员更好的阅读，但是机器执行时并不要这些符，把这些多余的符号给去除掉。</p>\n<p>接下来，就是无损压缩了，需要对原始资源建立统计模型，利用这个统计模型，将常出现的数据用较短的二进制比特序列表示，将不常出现的数据用较长的二进制比特序列表示，生成二进制比特序列一般是「霍夫曼编码」算法。</p>\n<p>gzip 就是比较常见的无损压缩。客户端支持的压缩算法，会在 HTTP 请求中通过头部中的 <code>Accept-Encoding</code> 字段告诉服务器：</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">Accept-Encoding: gzip, deflate, br<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>服务器收到后，会从中选择一个服务器支持的或者合适的压缩算法，然后使用此压缩算法对响应资源进行压缩，最后通过响应头部中的 <code>content-encoding</code> 字段告诉客户端该资源使用的压缩算法。</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">content-encoding: gzip<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>gzip 的压缩效率相比 Google 推出的 Brotli 算法还是差点意思，也就是上文中的 br，所以如果可以，服务器应该选择压缩效率更高的 br 压缩算法。</p>\n<h4 id=\"有损压缩\"><a href=\"#有损压缩\" class=\"headerlink\" title=\"有损压缩\"></a>有损压缩</h4><p>与无损压缩相对的就是有损压缩，经过此方法压缩，解压的数据会与原始数据不同但是非常接近。</p>\n<p>有损压缩主要将次要的数据舍弃，牺牲一些质量来减少数据量、提高压缩比，这种方法经常用于压缩多媒体数据，比如音频、视频、图片。</p>\n<p>可以通过 HTTP 请求头部中的 <code>Accept</code> 字段里的「 q 质量因子」，告诉服务器期望的资源质量。</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">Accept: audio/*; q=0.2, audio/basic<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>可以发现，相同图片质量下，WebP 格式的图片大小都比 Png 格式的图片小，所以对于大量图片的网站，可以考虑使用 WebP 格式的图片，这将大幅度提升网络传输的性能。</p>\n<p>关于音视频的压缩，音视频主要是动态的，每个帧都有时序的关系，通常时间连续的帧之间的变化是很小的。</p>\n<p>比如，一个在看书的视频，画面通常只有人物的手和书桌上的书是会有变化的，而其他地方通常都是静态的，于是只需要在一个静态的关键帧，使用<strong>增量数据</strong>来表达后续的帧，这样便减少了很多数据，提高了网络传输的性能。对于视频常见的编码格式有 H264、H265 等，音频常见的编码格式有 AAC、AC3。</p>\n<h2 id=\"HTTPS-RSA-握手解析\"><a href=\"#HTTPS-RSA-握手解析\" class=\"headerlink\" title=\"HTTPS RSA 握手解析\"></a>HTTPS RSA 握手解析</h2><p>TLS 协议是如何解决 HTTP 的风险的呢？</p>\n<ul>\n<li><em>信息加密</em>： HTTP 交互信息是被加密的，第三方就无法被窃取；</li>\n<li><em>校验机制</em>：校验信息传输过程中是否有被第三方篡改过，如果被篡改过，则会有警告提示；</li>\n<li><em>身份证书</em>：证明淘宝是真的淘宝网；</li>\n</ul>\n<p>可见，有了 TLS 协议，能保证 HTTP 通信是安全的了，那么在进行 HTTP 通信前，需要先进行 TLS 握手。</p>\n<div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/tls握手-(1).241m00so9k68.webp\"/>\n</div>\n\n<p>上图简要概述了 TLS 的握手过程，其中每一个「框」都是一个记录（<em>record</em>），记录是 TLS 收发数据的基本单位，类似于 TCP 里的 segment。多个记录可以组合成一个 TCP 包发送，所以<strong>通常经过「四个消息」就可以完成 TLS 握手，也就是需要 2个 RTT 的时延</strong>，然后就可以在安全的通信环境里发送 HTTP 报文，实现 HTTPS 协议。</p>\n<p>所以可以发现，HTTPS 是应用层协议，需要先完成 TCP 连接建立，然后走 TLS 握手过程后，才能建立通信安全的连接。</p>\n<p>事实上，不同的密钥交换算法，TLS 的握手过程可能会有一些区别。</p>\n<p>这里先简单介绍下密钥交换算法，因为考虑到性能的问题，所以双方在加密应用信息时使用的是对称加密密钥，而对称加密密钥是不能被泄漏的，为了保证对称加密密钥的安全性，所以使用非对称加密的方式来保护对称加密密钥的协商，这个工作就是密钥交换算法负责的。</p>\n<p>接下来，我们就以最简单的 <code>RSA</code> 密钥交换算法，来看看它的 TLS 握手过程。</p>\n<p>传统的 TLS 握手基本都是使用 RSA 算法来实现密钥交换的，在将 TLS 证书部署服务端时，证书文件其实就是服务端的公钥，会在 TLS 握手阶段传递给客户端，而服务端的私钥则一直留在服务端，一定要确保私钥不能被窃取。</p>\n<p>在 RSA 密钥协商算法中，客户端会生成随机密钥，并使用服务端的公钥加密后再传给服务端。根据非对称加密算法，公钥加密的消息仅能通过私钥解密，这样服务端解密后，双方就得到了相同的密钥，再用它加密应用消息。</p>\n<h3 id=\"TLS-第一次握手\"><a href=\"#TLS-第一次握手\" class=\"headerlink\" title=\"TLS 第一次握手\"></a>TLS 第一次握手</h3><p>客户端首先会发一个「<strong>Client Hello</strong>」消息，字面意思我们也能理解到，这是跟服务器「打招呼」。</p>\n<div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/clienthello.4opdhk93zqq0.webp\"/>\n</div>\n\n<p>消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的<strong>随机数（*Client Random*）</strong>，这个随机数会被服务端保留，它是生成对称加密密钥的材料之一。</p>\n<h3 id=\"TLS-第二次握手\"><a href=\"#TLS-第二次握手\" class=\"headerlink\" title=\"TLS 第二次握手\"></a>TLS 第二次握手</h3><p>当服务端收到客户端的「Client Hello」消息后，会确认 TLS 版本号是否支持，和从密码套件列表中选择一个密码套件，以及生成<strong>随机数（*Server Random*）</strong>。</p>\n<p>接着，返回「<strong>Server Hello</strong>」消息，消息里面有服务器确认的 TLS 版本号，也给出了随机数（Server Random），然后从客户端的密码套件列表选择了一个合适的密码套件。</p>\n<div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/serverhello.1lvezi5qgicg.webp\"/>\n</div>\n\n<p>可以看到，服务端选择的密码套件是 “Cipher Suite: TLS_RSA_WITH_AES_128_GCM_SHA256”。</p>\n<p>这个密码套件看起来真让人头晕，好一大串，但是其实它是有固定格式和规范的。基本的形式是「<strong>密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法</strong>」， 一般 WITH 单词前面有两个单词，第一个单词是约定密钥交换的算法，第二个单词是约定证书的验证算法。比如刚才的密码套件的意思就是：</p>\n<ul>\n<li>由于 WITH 单词只有一个 RSA，则说明握手时密钥交换算法和签名算法都是使用 RSA；</li>\n<li>握手后的通信使用 AES 对称算法，密钥长度 128 位，分组模式是 GCM；</li>\n<li>摘要算法 SHA256 用于消息认证和产生随机数；</li>\n</ul>\n<p>就前面这两个客户端和服务端相互「打招呼」的过程，客户端和服务端就已确认了 TLS 版本和使用的密码套件，而且你可能发现客户端和服务端都会各自生成一个随机数，并且还会把随机数传递给对方。</p>\n<p>那这个随机数有啥用呢？其实这两个随机数是后续作为生成「会话密钥」的条件，所谓的会话密钥就是数据传输时，所使用的对称加密密钥。</p>\n<p>然后，服务端为了证明自己的身份，会发送「<strong>Server Certificate</strong>」给客户端，这个消息里含有数字证书。</p>\n<div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/certificate.3cpx74w6rms0.webp\"/>\n</div>\n\n<p>随后，服务端发了「<strong>Server Hello Done</strong>」消息，目的是告诉客户端，我已经把该给你的东西都给你了，本次打招呼完毕。</p>\n<h3 id=\"客户端验证证书\"><a href=\"#客户端验证证书\" class=\"headerlink\" title=\"客户端验证证书\"></a>客户端验证证书</h3><p>在这里刹个车，客户端拿到了服务端的数字证书后，要怎么校验该数字证书是真实有效的呢？</p>\n<h4 id=\"数字证书和-CA-机构\"><a href=\"#数字证书和-CA-机构\" class=\"headerlink\" title=\"数字证书和 CA 机构\"></a>数字证书和 CA 机构</h4><p>在说校验数字证书是否可信的过程前，我们先来看看数字证书是什么，一个数字证书通常包含了：</p>\n<ul>\n<li>公钥；</li>\n<li>持有者信息；</li>\n<li>证书认证机构（CA）的信息；</li>\n<li>CA 对这份文件的数字签名及使用的算法；</li>\n<li>证书有效期；</li>\n<li>还有一些其他额外信息；</li>\n</ul>\n<p>那数字证书的作用，是用来认证公钥持有者的身份，以防止第三方进行冒充。说简单些，证书就是用来告诉客户端，该服务端是否是合法的，因为只有证书合法，才代表服务端身份是可信的。</p>\n<p>我们用证书来认证公钥持有者的身份（服务端的身份），那证书又是怎么来的？又该怎么认证证书呢？</p>\n<p>为了让服务端的公钥被大家信任，服务端的证书都是由 CA （<em>Certificate Authority</em>，证书认证机构）签名的，CA 就是网络世界里的公安局、公证中心，具有极高的可信度，所以由它来给各个公钥签名，信任的一方签发的证书，那必然证书也是被信任的。</p>\n<p>之所以要签名，是因为签名的作用可以避免中间人在获取证书时对证书内容的篡改。</p>\n<h4 id=\"数字证书签发和验证流程\"><a href=\"#数字证书签发和验证流程\" class=\"headerlink\" title=\"数字证书签发和验证流程\"></a>数字证书签发和验证流程</h4><p>CA 签发证书的过程，如上图左边部分：</p>\n<ul>\n<li>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</li>\n<li>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</li>\n<li>最后将 Certificate Signature 添加在文件证书上，形成数字证书；</li>\n</ul>\n<p>客户端校验服务端的数字证书的过程，如上图右边部分：</p>\n<ul>\n<li>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</li>\n<li>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；</li>\n<li>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</li>\n</ul>\n<h4 id=\"证书链\"><a href=\"#证书链\" class=\"headerlink\" title=\"证书链\"></a>证书链</h4><p>但事实上，证书的验证过程中<strong>还存在一个证书信任链的问题</strong>，因为我们向 CA 申请的证书一般不是根证书签发的，而是由中间证书签发的，比如百度的证书，从下图你可以看到，证书的层级有三级：</p>\n<p>对于这种三级层级关系的证书的验证过程如下：</p>\n<ul>\n<li>客户端收到 baidu.com 的证书后，发现这个证书的签发者不是根证书，就无法根据本地已有的根证书中的公钥去验证 baidu.com 证书是否可信。于是，客户端根据 baidu.com 证书中的签发者，找到该证书的颁发机构是 “GlobalSign Organization Validation CA - SHA256 - G2”，然后向 CA 请求该中间证书。</li>\n<li>请求到证书后发现 “GlobalSign Organization Validation CA - SHA256 - G2” 证书是由 “GlobalSign Root CA” 签发的，由于 “GlobalSign Root CA” 没有再上级签发机构，说明它是根证书，也就是自签证书。应用软件会检查此证书有否已预载于根证书清单上，如果有，则可以利用根证书中的公钥去验证 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，如果发现验证通过，就认为该中间证书是可信的。</li>\n<li>“GlobalSign Organization Validation CA - SHA256 - G2” 证书被信任后，可以使用 “GlobalSign Organization Validation CA - SHA256 - G2” 证书中的公钥去验证 baidu.com 证书的可信性，如果验证通过，就可以信任 baidu.com 证书。</li>\n</ul>\n<p>在这四个步骤中，最开始客户端只信任根证书 GlobalSign Root CA 证书的，然后 “GlobalSign Root CA” 证书信任 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，而 “GlobalSign Organization Validation CA - SHA256 - G2” 证书又信任 baidu.com 证书，于是客户端也信任 baidu.com 证书。</p>\n<p>总括来说，由于用户信任 GlobalSign，所以由 GlobalSign 所担保的 baidu.com 可以被信任，另外由于用户信任操作系统或浏览器的软件商，所以由软件商预载了根证书的 GlobalSign 都可被信任。</p>\n<p><strong>这是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题。</strong></p>\n<h3 id=\"TLS-第三次握手\"><a href=\"#TLS-第三次握手\" class=\"headerlink\" title=\"TLS 第三次握手\"></a>TLS 第三次握手</h3><p>客户端验证完证书后，认为可信则继续往下走。</p>\n<p>接着，客户端就会生成一个新的<strong>随机数 (*pre-master*)<strong>，用服务器的 RSA 公钥加密该随机数，通过「</strong>Client Key Exchange</strong>」消息传给服务端。</p>\n<div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/clietnkeyexchange.4zyukv38c1c0.webp\"/>\n</div>\n\n<p>服务端收到后，用 RSA 私钥解密，得到客户端发来的随机数 (pre-master)。</p>\n<p>至此，<strong>客户端和服务端双方都共享了三个随机数，分别是 Client Random、Server Random、pre-master</strong>。</p>\n<p>于是，双方根据已经得到的三个随机数，生成<strong>会话密钥（Master Secret）</strong>，它是对称密钥，用于对后续的 HTTP 请求&#x2F;响应的数据加解密。</p>\n<p>生成完「会话密钥」后，然后客户端发一个「<strong>Change Cipher Spec</strong>」，告诉服务端开始使用加密方式发送消息。</p>\n<p>然后，客户端再发一个「<strong>Encrypted Handshake Message（Finishd）</strong>」消息，把之前所有发送的数据做个<strong>摘要</strong>，再用会话密钥（master secret）加密一下，让服务器做个验证，验证加密通信「是否可用」和「之前握手信息是否有被中途篡改过」。</p>\n<p>可以发现，「Change Cipher Spec」之前传输的 TLS 握手数据都是明文，之后都是对称密钥加密的密文。</p>\n<h3 id=\"TLS-第四次握手\"><a href=\"#TLS-第四次握手\" class=\"headerlink\" title=\"TLS 第四次握手\"></a>TLS 第四次握手</h3><p>服务器也是同样的操作，发「<strong>Change Cipher Spec</strong>」和「<strong>Encrypted Handshake Message</strong>」消息，如果双方都验证加密和解密没问题，那么握手正式完成。</p>\n<p>最后，就用「会话密钥」加解密 HTTP 请求和响应了。</p>\n<h3 id=\"RSA-算法的缺陷\"><a href=\"#RSA-算法的缺陷\" class=\"headerlink\" title=\"RSA 算法的缺陷\"></a>RSA 算法的缺陷</h3><p><strong>使用 RSA 密钥协商算法的最大问题是不支持前向保密</strong>。</p>\n<p>因为客户端传递随机数（用于生成对称加密密钥的条件之一）给服务端时使用的是公钥加密的，服务端收到后，会用私钥解密得到随机数。所以一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解。</p>\n<p>为了解决这个问题，后面就出现了 ECDHE 密钥协商算法，我们现在大多数网站使用的正是 ECDHE 密钥协商算法。</p>\n<h2 id=\"HTTPS-ECDHE-握手解析\"><a href=\"#HTTPS-ECDHE-握手解析\" class=\"headerlink\" title=\"HTTPS ECDHE 握手解析\"></a>HTTPS ECDHE 握手解析</h2><h3 id=\"离散对数\"><a href=\"#离散对数\" class=\"headerlink\" title=\"离散对数\"></a>离散对数</h3><p>对数运算的取值是可以连续的，而离散对数的取值是不能连续的，因此也以「离散」得名，</p>\n<p>离散对数是在对数运算的基础上加了「模运算」，也就说取余数，对应编程语言的操作符是「%」，也可以用 mod 表示。</p>\n<p>底数 a 和模数 p 是离散对数的公共参数，也就说是公开的，b 是真数，i 是对数。知道了对数，就可以用上面的公式计算出真数。但反过来，知道真数却很难推算出对数。</p>\n<p><strong>特别是当模数 p 是一个很大的质数，即使知道底数 a 和真数 b ，在现有的计算机的计算水平是几乎无法算出离散对数的，这就是 DH 算法的数学基础。</strong></p>\n<h3 id=\"DH-算法\"><a href=\"#DH-算法\" class=\"headerlink\" title=\"DH 算法\"></a>DH 算法</h3><p>现假设小红和小明约定使用 DH 算法来交换密钥，那么基于离散对数，小红和小明需要先确定模数和底数作为算法的参数，这两个参数是公开的，用 P 和 G 来代称。</p>\n<p>然后小红和小明各自生成一个随机整数作为<strong>私钥</strong>，双方的私钥要各自严格保管，不能泄漏，小红的私钥用 a 代称，小明的私钥用 b 代称。</p>\n<p>现在小红和小明双方都有了 P 和 G 以及各自的私钥，于是就可以计算出<strong>公钥</strong>：</p>\n<ul>\n<li>小红的公钥记作 A，A &#x3D; G ^ a ( mod P )；</li>\n<li>小明的公钥记作 B，B &#x3D; G ^ b ( mod P )；</li>\n</ul>\n<p>A 和 B 也是公开的，因为根据离散对数的原理，从真数（A 和 B）反向计算对数 a 和 b 是非常困难的，至少在现有计算机的计算能力是无法破解的，如果量子计算机出来了，那就有可能被破解，当然如果量子计算机真的出来了，那么密钥协商算法就要做大的升级了。</p>\n<p>双方交换各自 DH 公钥后，小红手上共有 5 个数：P、G、a、A、B，小明手上也同样共有 5 个数：P、G、b、B、A。</p>\n<p>然后小红执行运算： B ^ a ( mod P )，其结果为 K，因为离散对数的幂运算有交换律，所以小明执行运算： A ^ b ( mod P )，得到的结果也是 K。</p>\n<p>这个 K 就是小红和小明之间用的<strong>对称加密密钥</strong>，可以作为会话密钥使用。</p>\n<p>可以看到，整个密钥协商过程中，小红和小明公开了 4 个信息：P、G、A、B，其中 P、G 是算法的参数，A 和 B 是公钥，而 a、b 是双方各自保管的私钥，黑客无法获取这 2 个私钥，因此黑客只能从公开的 P、G、A、B 入手，计算出离散对数（私钥）。</p>\n<p>前面也多次强调， 根据离散对数的原理，如果 P 是一个大数，在现有的计算机的计算能力是很难破解出 私钥 a、b 的，破解不出私钥，也就无法计算出会话密钥，因此 DH 密钥交换是安全的。</p>\n<h3 id=\"DHE-算法\"><a href=\"#DHE-算法\" class=\"headerlink\" title=\"DHE 算法\"></a>DHE 算法</h3><p>根据私钥生成的方式，DH 算法分为两种实现：</p>\n<ul>\n<li>static DH 算法，这个是已经被废弃了；</li>\n<li>DHE 算法，现在常用的；</li>\n</ul>\n<p>static DH 算法里有一方的私钥是静态的，也就说每次密钥协商的时候有一方的私钥都是一样的，一般是服务器方固定，即 a 不变，客户端的私钥则是随机生成的。</p>\n<p>于是，DH 交换密钥时就只有客户端的公钥是变化，而服务端公钥是不变的，那么随着时间延长，黑客就会截获海量的密钥协商过程的数据，因为密钥协商的过程有些数据是公开的，黑客就可以依据这些数据暴力破解出服务器的私钥，然后就可以计算出会话密钥了，于是之前截获的加密数据会被破解，所以 <strong>static DH 算法不具备前向安全性</strong>。</p>\n<p>既然固定一方的私钥有被破解的风险，那么干脆就让双方的私钥在每次密钥交换通信时，都是随机生成的、临时的，这个方式也就是 DHE 算法，E 全称是 ephemeral（临时性的）。</p>\n<p>所以，即使有个牛逼的黑客破解了某一次通信过程的私钥，其他通信过程的私钥仍然是安全的，因为<strong>每个通信过程的私钥都是没有任何关系的，都是独立的，这样就保证了「前向安全」</strong>。</p>\n<h3 id=\"ECDHE-算法\"><a href=\"#ECDHE-算法\" class=\"headerlink\" title=\"ECDHE 算法\"></a>ECDHE 算法</h3><p>DHE 算法由于计算性能不佳，因为需要做大量的乘法，为了提升 DHE 算法的性能，所以就出现了现在广泛用于密钥交换算法 —— <strong>ECDHE 算法</strong>。</p>\n<p>ECDHE 算法是在 DHE 算法的基础上利用了 ECC 椭圆曲线特性，可以用更少的计算量计算出公钥，以及最终的会话密钥。</p>\n<p>小红和小明使用 ECDHE 密钥交换算法的过程：</p>\n<ul>\n<li>双方事先确定好使用哪种椭圆曲线，和曲线上的基点 G，这两个参数都是公开的；</li>\n<li>双方各自随机生成一个随机数作为<strong>私钥d</strong>，并与基点 G相乘得到<strong>公钥Q</strong>（Q &#x3D; dG），此时小红的公私钥为 Q1 和 d1，小明的公私钥为 Q2 和 d2；</li>\n<li>双方交换各自的公钥，最后小红计算点（x1，y1） &#x3D; d1Q2，小明计算点（x2，y2） &#x3D; d2Q1，由于椭圆曲线上是可以满足乘法交换和结合律，所以 d1Q2 &#x3D; d1d2G &#x3D; d2d1G &#x3D; d2Q1 ，因此<strong>双方的 x 坐标是一样的，所以它是共享密钥，也就是会话密钥</strong>。</li>\n</ul>\n<p>这个过程中，双方的私钥都是随机、临时生成的，都是不公开的，即使根据公开的信息（椭圆曲线、公钥、基点 G）也是很难计算出椭圆曲线上的离散对数（私钥）。</p>\n<h3 id=\"ECDHE-握手过程\"><a href=\"#ECDHE-握手过程\" class=\"headerlink\" title=\"ECDHE 握手过程\"></a>ECDHE 握手过程</h3><div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/ech_tls握手.5ozhzkzpabo0.webp\"/>\n</div>\n\n<p><strong>使用了 ECDHE，在 TLS 第四次握手前，客户端就已经发送了加密的 HTTP 数据</strong>，而对于 RSA 握手过程，必须要完成 TLS 四次握手，才能传输应用数据。</p>\n<p>所以，<strong>ECDHE 相比 RSA 握手过程省去了一个消息往返的时间</strong>，这个有点「抢跑」的意思，它被称为是「<em>TLS False Start</em>」，跟「<em>TCP Fast Open</em>」有点像，都是在还没连接完全建立前，就发送了应用数据，这样便提高了传输的效率。</p>\n<h4 id=\"TLS-第一次握手-1\"><a href=\"#TLS-第一次握手-1\" class=\"headerlink\" title=\"TLS 第一次握手\"></a>TLS 第一次握手</h4><p>客户端首先会发一个「<strong>Client Hello</strong>」消息，消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的<strong>随机数（*Client Random*）</strong>。</p>\n<h4 id=\"TLS-第二次握手-1\"><a href=\"#TLS-第二次握手-1\" class=\"headerlink\" title=\"TLS 第二次握手\"></a>TLS 第二次握手</h4><p>服务端收到客户端的「打招呼」，同样也要回礼，会返回「<strong>Server Hello</strong>」消息，消息面有服务器确认的 TLS 版本号，也给出了一个<strong>随机数（*Server Random*）</strong>，然后从客户端的密码套件列表选择了一个合适的密码套件。</p>\n<p>不过，这次选择的密码套件就和 RSA 不一样了，我们来分析一下这次的密码套件的意思。</p>\n<p>「 TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384」</p>\n<ul>\n<li>密钥协商算法使用 ECDHE；</li>\n<li>签名算法使用 RSA；</li>\n<li>握手后的通信使用 AES 对称算法，密钥长度 256 位，分组模式是 GCM；</li>\n<li>摘要算法使用 SHA384；</li>\n</ul>\n<p>接着，服务端为了证明自己的身份，发送「<strong>Certificate</strong>」消息，会把证书也发给客户端。</p>\n<p>这一步就和 RSA 握手过程有很大的区别了，因为服务端选择了 ECDHE 密钥协商算法，所以会在发送完证书后，发送「<strong>Server Key Exchange</strong>」消息。</p>\n<p>这个过程服务器做了三件事：</p>\n<ul>\n<li>选择了<strong>名为 x25519 的椭圆曲线</strong>，选好了椭圆曲线相当于椭圆曲线基点 G 也定好了，这些都会公开给客户端；</li>\n<li>生成随机数作为服务端椭圆曲线的私钥，保留到本地；</li>\n<li>根据基点 G 和私钥计算出<strong>服务端的椭圆曲线公钥</strong>，这个会公开给客户端。</li>\n</ul>\n<p>为了保证这个椭圆曲线的公钥不被第三方篡改，服务端会用 RSA 签名算法给服务端的椭圆曲线公钥做个签名。</p>\n<p>随后，就是「<strong>Server Hello Done</strong>」消息，服务端跟客户端表明：“这些就是我提供的信息，打招呼完毕”。</p>\n<p>至此，TLS 两次握手就已经完成了，目前客户端和服务端通过明文共享了这几个信息：<strong>Client Random、Server Random 、使用的椭圆曲线、椭圆曲线基点 G、服务端椭圆曲线的公钥</strong>，这几个信息很重要，是后续生成会话密钥的材料。</p>\n<h4 id=\"TLS-第三次握手-1\"><a href=\"#TLS-第三次握手-1\" class=\"headerlink\" title=\"TLS 第三次握手\"></a>TLS 第三次握手</h4><p>客户端收到了服务端的证书后，自然要校验证书是否合法，如果证书合法，那么服务端到身份就是没问题的。校验证书的过程会走证书链逐级验证，确认证书的真实性，再用证书的公钥验证签名，这样就能确认服务端的身份了，确认无误后，就可以继续往下走。</p>\n<p>客户端会生成一个随机数作为客户端椭圆曲线的私钥，然后再根据服务端前面给的信息，生成<strong>客户端的椭圆曲线公钥</strong>，然后用「<strong>Client Key Exchange</strong>」消息发给服务端。</p>\n<p>至此，双方都有对方的椭圆曲线公钥、自己的椭圆曲线私钥、椭圆曲线基点 G。于是，双方都就计算出点（x，y），其中 x 坐标值双方都是一样的，前面说 ECDHE 算法时候，说 x 是会话密钥，<strong>但实际应用中，x 还不是最终的会话密钥</strong>。</p>\n<p>还记得 TLS 握手阶段，客户端和服务端都会生成了一个随机数传递给对方吗？</p>\n<p><strong>最终的会话密钥，就是用「客户端随机数 + 服务端随机数 + x（ECDHE 算法算出的共享密钥） 」三个材料生成的</strong>。</p>\n<p>之所以这么麻烦，是因为 TLS 设计者不信任客户端或服务器「伪随机数」的可靠性，为了保证真正的完全随机，把三个不可靠的随机数混合起来，那么「随机」的程度就非常高了，足够让黑客计算不出最终的会话密钥，安全性更高。</p>\n<p>算好会话密钥后，客户端会发一个「<strong>Change Cipher Spec</strong>」消息，告诉服务端后续改用对称算法加密通信。</p>\n<p>接着，客户端会发「<strong>Encrypted Handshake Message</strong>」消息，把之前发送的数据做一个摘要，再用对称密钥加密一下，让服务端做个验证，验证下本次生成的对称密钥是否可以正常使用。</p>\n<h4 id=\"TLS-第四次握手-1\"><a href=\"#TLS-第四次握手-1\" class=\"headerlink\" title=\"TLS 第四次握手\"></a>TLS 第四次握手</h4><p>最后，服务端也会有一个同样的操作，发「<strong>Change Cipher Spec</strong>」和「<strong>Encrypted Handshake Message</strong>」消息，如果双方都验证加密和解密没问题，那么握手正式完成。于是，就可以正常收发加密的 HTTP 请求和响应了。</p>\n<p>RSA 和 ECDHE 握手过程的区别：</p>\n<ul>\n<li>RSA 密钥协商算法「不支持」前向保密，ECDHE 密钥协商算法「支持」前向保密；</li>\n<li>使用了 RSA 密钥协商算法，TLS 完成四次握手后，才能进行应用数据传输，而对于 ECDHE 算法，客户端可以不用等服务端的最后一次 TLS 握手，就可以提前发出加密的 HTTP 数据，节省了一个消息的往返时间（这个是 RFC 文档规定的，具体原因文档没有说明，所以这点我也不太明白）；</li>\n<li>使用 ECDHE， 在 TLS 第 2 次握手中，会出现服务器端发出的「Server Key Exchange」消息，而 RSA 握手过程没有该消息；</li>\n</ul>\n<h2 id=\"HTTPS-如何优化？\"><a href=\"#HTTPS-如何优化？\" class=\"headerlink\" title=\"HTTPS 如何优化？\"></a>HTTPS 如何优化？</h2><p>既然要对 HTTPS 优化，那得清楚哪些步骤会产生性能消耗，再对症下药。</p>\n<p>产生性能消耗的两个环节：</p>\n<ul>\n<li>第一个环节， TLS 协议握手过程；</li>\n<li>第二个环节，握手后的对称加密报文传输。</li>\n</ul>\n<p>对于第二环节，现在主流的对称加密算法 AES、ChaCha20 性能都是不错的，而且一些 CPU 厂商还针对它们做了硬件级别的优化，因此这个环节的性能消耗可以说非常地小。</p>\n<p>而第一个环节，TLS 协议握手过程不仅增加了网络延时（最长可以花费掉 2 RTT），而且握手过程中的一些步骤也会产生性能损耗，比如：</p>\n<ul>\n<li>对于 ECDHE 密钥协商算法，握手过程中会客户端和服务端都需要临时生成椭圆曲线公私钥；</li>\n<li>客户端验证证书时，会访问 CA 获取 CRL 或者 OCSP，目的是验证服务器的证书是否有被吊销；</li>\n<li>双方计算 Pre-Master，也就是对称加密密钥；</li>\n</ul>\n<h3 id=\"硬件优化\"><a href=\"#硬件优化\" class=\"headerlink\" title=\"硬件优化\"></a>硬件优化</h3><p>对于计算机里也是一样，软件都是跑在物理硬件上，硬件越牛逼，软件跑的也越快，所以如果要优化 HTTPS 优化，最直接的方式就是花钱买性能参数更牛逼的硬件。</p>\n<p>但是花钱也要花对方向，<strong>HTTPS 协议是计算密集型，而不是 I&#x2F;O 密集型</strong>，所以不能把钱花在网卡、硬盘等地方，应该花在 CPU 上。</p>\n<p>一个好的 CPU，可以提高计算性能，因为 HTTPS 连接过程中就有大量需要计算密钥的过程，所以这样可以加速 TLS 握手过程。</p>\n<p>另外，如果可以，应该选择可以<strong>支持 AES-NI 特性的 CPU</strong>，因为这种款式的 CPU 能在指令级别优化了 AES 算法，这样便加速了数据的加解密传输过程。</p>\n<h3 id=\"软件优化\"><a href=\"#软件优化\" class=\"headerlink\" title=\"软件优化\"></a>软件优化</h3><p>如果公司预算充足对于新的服务器是可以考虑购买更好的 CPU，但是对于已经在使用的服务器，硬件优化的方式可能就不太适合了，于是就要从软件的方向来优化了。</p>\n<p>软件的优化方向可以分层两种，一个是<strong>软件升级</strong>，一个是<strong>协议优化</strong>。</p>\n<p>先说第一个软件升级，软件升级就是将正在使用的软件升级到最新版本，因为最新版本不仅提供了最新的特性，也优化了以前软件的问题或性能。比如：</p>\n<ul>\n<li>将 Linux 内核从 2.x 升级到 4.x；</li>\n<li>将 OpenSSL 从 1.0.1 升级到 1.1.1；</li>\n<li>…</li>\n</ul>\n<p>看似简单的软件升级，对于有成百上千服务器的公司来说，软件升级也跟硬件升级同样是一个棘手的问题，因为要实行软件升级，会花费时间和人力，同时也存在一定的风险，也可能会影响正常的线上服务。</p>\n<p>既然如此，我们把目光放到协议优化，也就是在现有的环节下，通过较小的改动，来进行优化。</p>\n<h3 id=\"协议优化\"><a href=\"#协议优化\" class=\"headerlink\" title=\"协议优化\"></a>协议优化</h3><p>协议的优化就是对「密钥交换过程」进行优化。</p>\n<h4 id=\"密钥交换算法优化\"><a href=\"#密钥交换算法优化\" class=\"headerlink\" title=\"密钥交换算法优化\"></a>密钥交换算法优化</h4><p>TLS 1.2 版本如果使用的是 RSA 密钥交换算法，那么需要 4 次握手，也就是要花费 2 RTT，才可以进行应用数据的传输，而且 RSA 密钥交换算法不具备前向安全性。</p>\n<p>总之使用 <strong>RSA 密钥交换算法的 TLS 握手过程，不仅慢，而且安全性也不高</strong>。</p>\n<p>因此如果可以，尽量<strong>选用 ECDHE 密钥交换</strong>算法替换 RSA 算法，因为该算法由于支持「False Start」，它是“抢跑”的意思，客户端可以在 TLS 协议的第 3 次握手后，第 4 次握手前，发送加密的应用数据，以此将 <strong>TLS 握手的消息往返由 2 RTT 减少到 1 RTT，而且安全性也高，具备前向安全性</strong>。</p>\n<p>ECDHE 算法是基于椭圆曲线实现的，不同的椭圆曲线性能也不同，应该尽量<strong>选择 x25519 曲线</strong>，该曲线是目前最快的椭圆曲线。</p>\n<p>比如在 Nginx 上，可以使用 ssl_ecdh_curve 指令配置想使用的椭圆曲线，把优先使用的放在前面：</p>\n<p>对于对称加密算法方面，如果对安全性不是特别高的要求，可以<strong>选用 AES_128_GCM</strong>，它比 AES_256_GCM 快一些，因为密钥的长度短一些。</p>\n<p>比如在 Nginx 上，可以使用 ssl_ciphers 指令配置想使用的非对称加密算法和对称加密算法，也就是密钥套件，而且把性能最快最安全的算法放在最前面</p>\n<h4 id=\"TLS-升级\"><a href=\"#TLS-升级\" class=\"headerlink\" title=\"TLS 升级\"></a>TLS 升级</h4><p>当然，如果可以，直接把 TLS 1.2 升级成 TLS 1.3，TLS 1.3 大幅度简化了握手的步骤，<strong>完成 TLS 握手只要 1 RTT</strong>，而且安全性更高。</p>\n<p>在 TLS 1.2 的握手中，一般是需要 4 次握手，先要通过 Client Hello （第 1 次握手）和 Server Hello（第 2 次握手） 消息协商出后续使用的加密算法，再互相交换公钥（第 3 和 第 4 次握手），然后计算出最终的会话密钥，下图的左边部分就是 TLS 1.2 的握手过程：</p>\n<div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/tls1.4ozpojlp09k0.webp\"/>\n</div>\n\n<p>上图的右边部分就是 TLS 1.3 的握手过程，可以发现 <strong>TLS 1.3 把 Hello 和公钥交换这两个消息合并成了一个消息，于是这样就减少到只需 1 RTT 就能完成 TLS 握手</strong>。</p>\n<p>怎么合并的呢？具体的做法是，客户端在 Client Hello 消息里带上了支持的椭圆曲线，以及这些椭圆曲线对应的公钥。</p>\n<p>服务端收到后，选定一个椭圆曲线等参数，然后返回消息时，带上服务端这边的公钥。经过这 1 个 RTT，双方手上已经有生成会话密钥的材料了，于是客户端计算出会话密钥，就可以进行应用数据的加密传输了。</p>\n<p>而且，TLS1.3 对密码套件进行“减肥”了， <strong>对于密钥交换算法，废除了不支持前向安全性的 RSA 和 DH 算法，只支持 ECDHE 算法</strong>。</p>\n<p>对于对称加密和签名算法，只支持目前最安全的几个密码套件，比如 openssl 中仅支持下面 5 种密码套件：</p>\n<ul>\n<li>TLS_AES_256_GCM_SHA384</li>\n<li>TLS_CHACHA20_POLY1305_SHA256</li>\n<li>TLS_AES_128_GCM_SHA256</li>\n<li>TLS_AES_128_CCM_8_SHA256</li>\n<li>TLS_AES_128_CCM_SHA256</li>\n</ul>\n<p>之所以 TLS1.3 仅支持这么少的密码套件，是因为 TLS1.2 由于支持各种古老且不安全的密码套件，中间人可以利用降级攻击，伪造客户端的 Client Hello 消息，替换客户端支持的密码套件为一些不安全的密码套件，使得服务器被迫使用这个密码套件进行 HTTPS 连接，从而破解密文。</p>\n<p>细节可以参考这篇文章：<a href=\"https://blog.csdn.net/qq_35324057/article/details/105366368\">TLS1.3 概述_Stride Max Zz的博客-CSDN博客_tls1.3</a>总结来说就是首先减少了一个RTT，其次可以抢跑再少一个变成0，同时支持了会话复用还有降级保护。</p>\n<h3 id=\"证书优化\"><a href=\"#证书优化\" class=\"headerlink\" title=\"证书优化\"></a>证书优化</h3><p>对于证书的优化，可以有两个方向：</p>\n<ul>\n<li>一个是<strong>证书传输</strong>，</li>\n<li>一个是<strong>证书验证</strong>；</li>\n</ul>\n<h4 id=\"传输优化\"><a href=\"#传输优化\" class=\"headerlink\" title=\"传输优化\"></a>传输优化</h4><p>要让证书更便于传输，那必然是减少证书的大小，这样可以节约带宽，也能减少客户端的运算量。所以，<strong>对于服务器的证书应该选择椭圆曲线（ECDSA）证书，而不是 RSA 证书，因为在相同安全强度下， ECC 密钥长度比 RSA 短的多</strong>。</p>\n<h4 id=\"验证优化\"><a href=\"#验证优化\" class=\"headerlink\" title=\"验证优化\"></a>验证优化</h4><p>客户端在验证证书时，是个复杂的过程，会走证书链逐级验证，验证的过程不仅需要「用 CA 公钥解密证书」以及「用签名算法验证证书的完整性」，而且为了知道证书是否被 CA 吊销，客户端有时还会再去访问 CA， 下载 CRL 或者 OCSP 数据，以此确认证书的有效性。</p>\n<p>这个访问过程是 HTTP 访问，因此又会产生一系列网络通信的开销，如 DNS 查询、建立连接、收发数据等。</p>\n<p>CRL 称为证书吊销列表（<em>Certificate Revocation List</em>），这个列表是由 CA 定期更新，列表内容都是被撤销信任的证书序号，如果服务器的证书在此列表，就认为证书已经失效，不在的话，则认为证书是有效的。</p>\n<p>但是 CRL 存在两个问题：</p>\n<ul>\n<li>第一个问题，由于 CRL 列表是由 CA 维护的，定期更新，如果一个证书刚被吊销后，客户端在更新 CRL 之前还是会信任这个证书，<strong>实时性较差</strong>；</li>\n<li>第二个问题，<strong>随着吊销证书的增多，列表会越来越大，下载的速度就会越慢</strong>，下载完客户端还得遍历这么大的列表，那么就会导致客户端在校验证书这一环节的延时很大，进而拖慢了 HTTPS 连接。</li>\n<li>因此，现在基本都是使用 OCSP ，名为在线证书状态协议（<em>Online Certificate Status Protocol</em>）来查询证书的有效性，它的工作方式是<strong>向 CA 发送查询请求，让 CA 返回证书的有效状态</strong>。</li>\n</ul>\n<p>不必像 CRL 方式客户端需要下载大大的列表，还要从列表查询，同时因为可以实时查询每一张证书的有效性，解决了 CRL 的实时性问题。</p>\n<p>OCSP 需要向 CA 查询，因此也是要发生网络请求，而且还得看 CA 服务器的“脸色”，如果网络状态不好，或者 CA 服务器繁忙，也会导致客户端在校验证书这一环节的延时变大。</p>\n<p>于是为了解决这一个网络开销，就出现了 OCSP Stapling，其原理是：服务器向 CA 周期性地查询证书状态，获得一个带有时间戳和签名的响应结果并缓存它。</p>\n<p>当有客户端发起连接请求时，服务器会把这个「响应结果」在 TLS 握手过程中发给客户端。由于有签名的存在，服务器无法篡改，因此客户端就能得知证书是否已被吊销了，这样客户端就不需要再去查询。</p>\n<h3 id=\"会话复用\"><a href=\"#会话复用\" class=\"headerlink\" title=\"会话复用\"></a>会话复用</h3><p>TLS 握手的目的就是为了协商出会话密钥，也就是对称加密密钥，那我们如果我们把首次 TLS 握手协商的对称加密密钥缓存起来，待下次需要建立 HTTPS 连接时，直接「复用」这个密钥，不就减少 TLS 握手的性能损耗了吗？</p>\n<p>这种方式就是<strong>会话复用</strong>（<em>TLS session resumption</em>），会话复用分两种：</p>\n<ul>\n<li>第一种叫 Session ID；</li>\n<li>第二种叫 Session Ticket；</li>\n</ul>\n<h4 id=\"Session-ID\"><a href=\"#Session-ID\" class=\"headerlink\" title=\"Session ID\"></a>Session ID</h4><p>Session ID 的工作原理是，<strong>客户端和服务器首次 TLS 握手连接后，双方会在内存缓存会话密钥，并用唯一的 Session ID 来标识</strong>，Session ID 和会话密钥相当于 key-value 的关系。</p>\n<p>当客户端再次连接时，hello 消息里会带上 Session ID，服务器收到后就会从内存找，如果找到就直接用该会话密钥恢复会话状态，跳过其余的过程，只用一个消息往返就可以建立安全通信。当然为了安全性，内存中的会话密钥会定期失效。</p>\n<p>但是它有两个缺点：</p>\n<ul>\n<li>服务器必须保持每一个客户端的会话密钥，随着客户端的增多，<strong>服务器的内存压力也会越大</strong>。</li>\n<li>现在网站服务一般是由多台服务器通过负载均衡提供服务的，<strong>客户端再次连接不一定会命中上次访问过的服务器</strong>，于是还要走完整的 TLS 握手过程；</li>\n</ul>\n<h4 id=\"Session-Ticket\"><a href=\"#Session-Ticket\" class=\"headerlink\" title=\"Session Ticket\"></a>Session Ticket</h4><p>为了解决 Session ID 的问题，就出现了 Session Ticket，<strong>服务器不再缓存每个客户端的会话密钥，而是把缓存的工作交给了客户端</strong>，类似于 HTTP 的 Cookie。</p>\n<p>客户端与服务器首次建立连接时，服务器会加密「会话密钥」作为 Ticket 发给客户端，交给客户端缓存该 Ticket。</p>\n<p>客户端再次连接服务器时，客户端会发送 Ticket，服务器解密后就可以获取上一次的会话密钥，然后验证有效期，如果没问题，就可以恢复会话了，开始加密通信。</p>\n<p>对于集群服务器的话，<strong>要确保每台服务器加密 「会话密钥」的密钥是一致的</strong>，这样客户端携带 Ticket 访问任意一台服务器时，都能恢复会话。</p>\n<p>Session ID 和 Session Ticket <strong>都不具备前向安全性</strong>，因为一旦加密「会话密钥」的密钥被破解或者服务器泄漏「会话密钥」，前面劫持的通信密文都会被破解。</p>\n<h4 id=\"Pre-shared-Key\"><a href=\"#Pre-shared-Key\" class=\"headerlink\" title=\"Pre-shared Key\"></a>Pre-shared Key</h4><p>前面的 Session ID 和 Session Ticket 方式都需要在 1 RTT 才能恢复会话。</p>\n<p>而 TLS1.3 更为牛逼，对于重连 TLS1.3 只需要 <strong>0 RTT</strong>，原理和 Ticket 类似，只不过在重连时，客户端会把 Ticket 和 HTTP 请求一同发送给服务端，这种方式叫 <strong>Pre-shared Key</strong>。</p>\n<p>假设中间人通过某种方式，截获了客户端使用会话重用技术的 POST 请求，通常 POST 请求是会改变数据库的数据，然后中间人就可以把截获的这个报文发送给服务器，服务器收到后，也认为是合法的，于是就恢复会话，致使数据库的数据又被更改，但是此时用户是不知情的。</p>\n<p>所以，应对重放攻击可以给会话密钥设定一个合理的过期时间，以及只针对安全的 HTTP 请求如 GET&#x2F;HEAD 使用会话重用。</p>\n<p>对于硬件优化的方向，因为 HTTPS 是属于计算密集型，应该选择计算力更强的 CPU，而且最好选择<strong>支持 AES-NI 特性的 CPU</strong>，这个特性可以在硬件级别优化 AES 对称加密算法，加快应用数据的加解密。</p>\n<p>对于软件优化的方向，如果可以，把软件升级成较新的版本，比如将 Linux 内核 2.X 升级成 4.X，将 openssl 1.0.1 升级到 1.1.1，因为新版本的软件不仅会提供新的特性，而且还会修复老版本的问题。</p>\n<p>对于协议优化的方向：</p>\n<ul>\n<li>密钥交换算法应该选择 <strong>ECDHE 算法</strong>，而不用 RSA 算法，因为 ECDHE 算法具备前向安全性，而且客户端可以在第三次握手之后，就发送加密应用数据，节省了 1 RTT。</li>\n<li>将 TLS1.2 升级 <strong>TLS1.3</strong>，因为 TLS1.3 的握手过程只需要 1 RTT，而且安全性更强。</li>\n</ul>\n<p>对于证书优化的方向：</p>\n<ul>\n<li>服务器应该选用 <strong>ECDSA 证书</strong>，而非 RSA 证书，因为在相同安全级别下，ECC 的密钥长度比 RSA 短很多，这样可以提高证书传输的效率；</li>\n<li>服务器应该开启 <strong>OCSP Stapling</strong> 功能，由服务器预先获得 OCSP 的响应，并把响应结果缓存起来，这样 TLS 握手的时候就不用再访问 CA 服务器，减少了网络通信的开销，提高了证书验证的效率；</li>\n</ul>\n<p>对于重连 HTTPS 时，我们可以使用一些技术让客户端和服务端使用上一次 HTTPS 连接使用的会话密钥，直接恢复会话，而不用再重新走完整的 TLS 握手过程。</p>\n<p>常见的<strong>会话重用</strong>技术有 Session ID 和 Session Ticket，用了会话重用技术，当再次重连 HTTPS 时，只需要 1 RTT 就可以恢复会话。对于 TLS1.3 使用 Pre-shared Key 会话重用技术，只需要 0 RTT 就可以恢复会话。</p>\n<p>这些会话重用技术虽然好用，但是存在一定的安全风险，它们不仅不具备前向安全，而且有重放攻击的风险，所以应当对会话密钥设定一个合理的过期时间。</p>\n<h2 id=\"HTTP-x2F-2\"><a href=\"#HTTP-x2F-2\" class=\"headerlink\" title=\"HTTP&#x2F;2\"></a>HTTP&#x2F;2</h2><p>我们得先要了解下 HTTP&#x2F;1.1 协议存在的性能问题，因为 HTTP&#x2F;2 协议就是把这些性能问题逐个攻破了。</p>\n<p>现在的站点相比以前变化太多了，比如：</p>\n<ul>\n<li><em>消息的大小变大了</em>，从几 KB 大小的消息，到几 MB 大小的消息；</li>\n<li><em>页面资源变多了</em>，从每个页面不到 10 个的资源，到每页超 100 多个资源；</li>\n<li><em>内容形式变多样了</em>，从单纯到文本内容，到图片、视频、音频等内容；</li>\n<li><em>实时性要求变高了</em>，对页面的实时性要求的应用越来越多；</li>\n</ul>\n<p>这些变化带来的最大性能问题就是 <strong>HTTP&#x2F;1.1 的高延迟</strong>，延迟高必然影响的就是用户体验。主要原因如下几个：</p>\n<ul>\n<li><em>延迟难以下降</em>，虽然现在网络的「带宽」相比以前变多了，但是延迟降到一定幅度后，就很难再下降了，说白了就是到达了延迟的下限；</li>\n<li><em>并发连接有限</em>，谷歌浏览器最大并发连接数是 6 个，而且每一个连接都要经过 TCP 和 TLS 握手耗时，以及 TCP 慢启动过程给流量带来的影响；</li>\n<li><em>队头阻塞问题</em>，同一连接只能在完成一个 HTTP 事务（请求和响应）后，才能处理下一个事务；</li>\n<li><em>HTTP 头部巨大且重复</em>，由于 HTTP 协议是无状态的，每一个请求都得携带 HTTP 头部，特别是对于有携带 cookie 的头部，而 cookie 的大小通常很大；</li>\n<li><em>不支持服务器推送消息</em>，因此当客户端需要获取通知时，只能通过定时器不断地拉取消息，这无疑浪费大量了带宽和服务器资源。</li>\n</ul>\n<p>尽管对 HTTP&#x2F;1.1 协议的优化手段如此之多，但是效果还是不尽人意，因为这些手段都是对 HTTP&#x2F;1.1 协议的“外部”做优化，<strong>而一些关键的地方是没办法优化的，比如请求-响应模型、头部巨大且重复、并发连接耗时、服务器不能主动推送等，要改变这些必须重新设计 HTTP 协议，于是 HTTP&#x2F;2 就出来了！</strong></p>\n<h3 id=\"兼容-HTTP-x2F-1-1\"><a href=\"#兼容-HTTP-x2F-1-1\" class=\"headerlink\" title=\"兼容 HTTP&#x2F;1.1\"></a>兼容 HTTP&#x2F;1.1</h3><p>HTTP&#x2F;2 出来的目的是为了改善 HTTP 的性能。协议升级有一个很重要的地方，就是要<strong>兼容</strong>老版本的协议，否则新协议推广起来就相当困难，所幸 HTTP&#x2F;2 做到了兼容 HTTP&#x2F;1.1 。</p>\n<p>那么，HTTP&#x2F;2 是怎么做的呢？</p>\n<p>第一点，HTTP&#x2F;2 没有在 URI 里引入新的协议名，仍然用「http:&#x2F;&#x2F;」表示明文协议，用「https:&#x2F;&#x2F;」表示加密协议，于是只需要浏览器和服务器在背后自动升级协议，这样可以让用户意识不到协议的升级，很好的实现了协议的平滑升级。</p>\n<p>第二点，只在应用层做了改变，还是基于 TCP 协议传输，应用层方面为了保持功能上的兼容，HTTP&#x2F;2 把 HTTP 分解成了「语义」和「语法」两个部分，「语义」层不做改动，与 HTTP&#x2F;1.1 完全一致，比如请求方法、状态码、头字段等规则保留不变。</p>\n<p>但是，HTTP&#x2F;2 在「语法」层面做了很多改造，基本改变了 HTTP 报文的传输格式。</p>\n<p>HTTP 协议的报文是由「Header + Body」构成的，对于 Body 部分，HTTP&#x2F;1.1 协议可以使用头字段 「Content-Encoding」指定 Body 的压缩方式，比如用 gzip 压缩，这样可以节约带宽，但报文中的另外一部分 Header，是没有针对它的优化手段。</p>\n<p>HTTP&#x2F;1.1 报文中 Header 部分存在的问题：</p>\n<ul>\n<li>含很多固定的字段，比如Cookie、User Agent、Accept 等，这些字段加起来也高达几百字节甚至上千字节，所以有必要<strong>压缩</strong>；</li>\n<li>大量的请求和响应的报文里有很多字段值都是重复的，这样会使得大量带宽被这些冗余的数据占用了，所以有必须要<strong>避免重复性</strong>；</li>\n<li>字段是 ASCII 编码的，虽然易于人类观察，但效率低，所以有必要改成<strong>二进制编码</strong>；</li>\n</ul>\n<p>HTTP&#x2F;2 对 Header 部分做了大改造，把以上的问题都解决了。</p>\n<p>HTTP&#x2F;2 没使用常见的 gzip 压缩方式来压缩头部，而是开发了 <strong>HPACK</strong> 算法，HPACK 算法主要包含三个组成部分：</p>\n<ul>\n<li>静态字典；</li>\n<li>动态字典；</li>\n<li>Huffman 编码（压缩算法）；</li>\n</ul>\n<p>客户端和服务器两端都会建立和维护「<strong>字典</strong>」，用长度较小的索引号表示重复的字符串，再用 Huffman 编码压缩数据，<strong>可达到 50%~90% 的高压缩率</strong>。</p>\n<h3 id=\"静态表编码\"><a href=\"#静态表编码\" class=\"headerlink\" title=\"静态表编码\"></a>静态表编码</h3><p>HT表中的 <code>Index</code> 表示索引（Key），<code>Header Value</code> 表示索引对应的 Value，<code>Header Name</code> 表示字段的名字，比如 Index 为 2 代表 GET，Index 为 8 代表状态码 200。</p>\n<p>你可能注意到，表中有的 Index 没有对应的 Header Value，这是因为这些 Value 并不是固定的而是变化的，这些 Value 都会经过 Huffman 编码后，才会发送出去。P&#x2F;2 为高频出现在头部的字符串和字段建立了一张<strong>静态表</strong>，它是写入到 HTTP&#x2F;2 框架里的，不会变化的，静态表里共有 <code>61</code> 组</p>\n<h3 id=\"动态表编码\"><a href=\"#动态表编码\" class=\"headerlink\" title=\"动态表编码\"></a>动态表编码</h3><p>静态表只包含了 61 种高频出现在头部的字符串，不在静态表范围内的头部字符串就要自行构建<strong>动态表</strong>，它的 Index 从 <code>62</code> 起步，会在编码解码的时候随时更新。</p>\n<p>比如，第一次发送时头部中的「<code>user-agent</code> 」字段数据有上百个字节，经过 Huffman 编码发送出去后，客户端和服务器双方都会更新自己的动态表，添加一个新的 Index 号 62。<strong>那么在下一次发送的时候，就不用重复发这个字段的数据了，只用发 1 个字节的 Index 号就好了，因为双方都可以根据自己的动态表获取到字段的数据</strong>。</p>\n<p>所以，使得动态表生效有一个前提：<strong>必须同一个连接上，重复传输完全相同的 HTTP 头部</strong>。如果消息字段在 1 个连接上只发送了 1 次，或者重复传输时，字段总是略有变化，动态表就无法被充分利用了。</p>\n<p>因此，随着在同一 HTTP&#x2F;2 连接上发送的报文越来越多，客户端和服务器双方的「字典」积累的越来越多，理论上最终每个头部字段都会变成 1 个字节的 Index，这样便避免了大量的冗余数据的传输，大大节约了带宽。</p>\n<p>理想很美好，现实很骨感。动态表越大，占用的内存也就越大，如果占用了太多内存，是会影响服务器性能的，因此 Web 服务器都会提供类似 <code>http2_max_requests</code> 的配置，用于限制一个连接上能够传输的请求数量，避免动态表无限增大，请求数量到达上限后，就会关闭 HTTP&#x2F;2 连接来释放内存。</p>\n<p>综上，HTTP&#x2F;2 头部的编码通过「静态表、动态表、Huffman 编码」共同完成的。</p>\n<h3 id=\"二进制帧\"><a href=\"#二进制帧\" class=\"headerlink\" title=\"二进制帧\"></a>二进制帧</h3><p>HTTP&#x2F;2 厉害的地方在于将 HTTP&#x2F;1 的文本格式改成二进制格式传输数据，极大提高了 HTTP 传输效率，而且二进制数据使用位运算能高效解析。</p>\n<p>你可以从下图看到，HTTP&#x2F;1.1 的响应 和 HTTP&#x2F;2 的区别：</p>\n<div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/二进制帧.3zlva68os080.webp\"/>\n</div>\n\n<p>HTTP&#x2F;2 把响应报文划分成了两类<strong>帧（*Frame*）</strong>，图中的 HEADERS（首部）和 DATA（消息负载） 是帧的类型，也就是说一条 HTTP 响应，划分成了两类帧来传输，并且采用二进制来编码。</p>\n<p>比如状态码 200 ，在 HTTP&#x2F;1.1 是用 ‘2’’0’’0’ 三个字符来表示（二进制：00110010 00110000 00110000），共用了 3 个字节</p>\n<p>帧头（Frame Header）很小，只有 9 个字节，帧开头的前 3 个字节表示帧数据（Frame Playload）的<strong>长度</strong>。</p>\n<p>帧长度后面的一个字节是表示<strong>帧的类型</strong>，HTTP&#x2F;2 总共定义了 10 种类型的帧，一般分为<strong>数据帧</strong>和<strong>控制帧</strong>两类</p>\n<p>帧类型后面的一个字节是<strong>标志位</strong>，可以保存 8 个标志位，用于携带简单的控制信息，比如：</p>\n<ul>\n<li><strong>END_HEADERS</strong> 表示头数据结束标志，相当于 HTTP&#x2F;1 里头后的空行（“\\r\\n”）；</li>\n<li><strong>END_Stream</strong> 表示单方向数据发送结束，后续不会再有数据帧。</li>\n<li><strong>PRIORITY</strong> 表示流的优先级；</li>\n</ul>\n<p>帧头的最后 4 个字节是<strong>流标识符</strong>（Stream ID），但最高位被保留不用，只有 31 位可以使用，因此流标识符的最大值是 2^31，大约是 21 亿，它的作用是用来标识该 Frame 属于哪个 Stream，接收方可以根据这个信息从乱序的帧里找到相同 Stream ID 的帧，从而有序组装信息。</p>\n<p>最后面就是<strong>帧数据</strong>了，它存放的是通过 <strong>HPACK 算法</strong>压缩过的 HTTP 头部和包体。</p>\n<h3 id=\"并发传输\"><a href=\"#并发传输\" class=\"headerlink\" title=\"并发传输\"></a>并发传输</h3><p>知道了 HTTP&#x2F;2 的帧结构后，我们再来看看它是如何实现<strong>并发传输</strong>的。</p>\n<p>我们都知道 HTTP&#x2F;1.1 的实现是基于请求-响应模型的。同一个连接中，HTTP 完成一个事务（请求与响应），才能处理下一个事务，也就是说在发出请求等待响应的过程中，是没办法做其他事情的，如果响应迟迟不来，那么后续的请求是无法发送的，也造成了<strong>队头阻塞</strong>的问题。</p>\n<p>而 HTTP&#x2F;2 就很牛逼了，通过 Stream 这个设计，<strong>多个 Stream 复用一条 TCP 连接，达到并发的效果</strong>，解决了 HTTP&#x2F;1.1 队头阻塞的问题，提高了 HTTP 传输的吞吐量。</p>\n<ul>\n<li>1 个 TCP 连接包含一个或者多个 Stream，Stream 是 HTTP&#x2F;2 并发的关键技术；</li>\n<li>Stream 里可以包含 1 个或多个 Message，Message 对应 HTTP&#x2F;1 中的请求或响应，由 HTTP 头部和包体构成；</li>\n<li>Message 里包含一条或者多个 Frame，Frame 是 HTTP&#x2F;2 最小单位，以二进制压缩格式存放 HTTP&#x2F;1 中的内容（头部和包体）；</li>\n</ul>\n<p>因此，我们可以得出个结论：多个 Stream 跑在一条 TCP 连接，同一个 HTTP 请求与响应是跑在同一个 Stream 中，HTTP 消息可以由多个 Frame 构成， 一个 Frame 可以由多个 TCP 报文构成。</p>\n<p>同一个连接中的 Stream ID 是不能复用的，只能顺序递增，所以当 Stream ID 耗尽时，需要发一个控制帧 <code>GOAWAY</code>，用来关闭 TCP 连接。</p>\n<p>在 Nginx 中，可以通过 <code>http2_max_concurrent_Streams</code> 配置来设置 Stream 的上限，默认是 128 个。</p>\n<p>HTTP&#x2F;2 通过 Stream 实现的并发，比 HTTP&#x2F;1.1 通过 TCP 连接实现并发要牛逼的多，<strong>因为当 HTTP&#x2F;2 实现 100 个并发 Stream 时，只需要建立一次 TCP 连接，而 HTTP&#x2F;1.1 需要建立 100 个 TCP 连接，每个 TCP 连接都要经过TCP 握手、慢启动以及 TLS 握手过程，这些都是很耗时的。</strong></p>\n<p>HTTP&#x2F;2 还可以对每个 Stream 设置不同<strong>优先级</strong>，帧头中的「标志位」可以设置优先级，比如客户端访问 HTML&#x2F;CSS 和图片资源时，希望服务器先传递 HTML&#x2F;CSS，再传图片，那么就可以通过设置 Stream 的优先级来实现，以此提高用户体验。</p>\n<h3 id=\"服务器主动推送资源\"><a href=\"#服务器主动推送资源\" class=\"headerlink\" title=\"服务器主动推送资源\"></a>服务器主动推送资源</h3><p>在 Nginx 中，如果你希望客户端访问 &#x2F;test.html 时，服务器直接推送 &#x2F;test.css，那么可以这么配置：</p>\n<pre class=\"line-numbers language-nginx\" data-language=\"nginx\"><code class=\"language-nginx\"><span class=\"token directive\"><span class=\"token keyword\">location</span> /test.html</span> <span class=\"token punctuation\">&#123;</span> \n  <span class=\"token directive\"><span class=\"token keyword\">http2_push</span> /test.css</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>那 HTTP&#x2F;2 的推送是怎么实现的？</p>\n<p>客户端发起的请求，必须使用的是奇数号 Stream，服务器主动的推送，使用的是偶数号 Stream。服务器在推送资源时，会通过 <code>PUSH_PROMISE</code> 帧传输 HTTP 头部，并通过帧中的 <code>Promised Stream ID</code> 字段告知客户端，接下来会在哪个偶数号 Stream 中发送包体。</p>\n<p>HTTP&#x2F;2 协议其实还有很多内容，比如流控制、流状态、依赖关系等等。</p>\n<p>这次主要介绍了关于 HTTP&#x2F;2 是如何提升性能的几个方向，它相比 HTTP&#x2F;1 大大提高了传输效率、吞吐能力。</p>\n<p>第一点，对于常见的 HTTP 头部通过<strong>静态表和 Huffman 编码</strong>的方式，将体积压缩了近一半，而且针对后续的请求头部，还可以建立<strong>动态表</strong>，将体积压缩近 90%，大大提高了编码效率，同时节约了带宽资源。</p>\n<p>不过，动态表并非可以无限增大， 因为动态表是会占用内存的，动态表越大，内存也越大，容易影响服务器总体的并发能力，因此服务器需要限制 HTTP&#x2F;2 连接时长或者请求次数。</p>\n<p>第二点，<strong>HTTP&#x2F;2 实现了 Stream 并发</strong>，多个 Stream 只需复用 1 个 TCP 连接，节约了 TCP 和 TLS 握手时间，以及减少了 TCP 慢启动阶段对流量的影响。不同的 Stream ID 可以并发，即使乱序发送帧也没问题，比如发送 A 请求帧1-&gt; B 请求帧1-&gt; A 请求帧2 -&gt; B 请求帧2，但是同一个 Stream 里的帧必须严格有序。</p>\n<p>另外，可以根据资源的渲染顺序来设置 Stream 的<strong>优先级</strong>，从而提高用户体验。</p>\n<p>第三点，<strong>服务器支持主动推送资源</strong>，大大提升了消息的传输性能，服务器推送资源时，会先发送 PUSH_PROMISE 帧，告诉客户端接下来在哪个 Stream 发送资源，然后用偶数号 Stream 发送资源给客户端。</p>\n<p>HTTP&#x2F;2 通过 Stream 的并发能力，解决了 HTTP&#x2F;1 队头阻塞的问题，看似很完美了，但是 HTTP&#x2F;2 还是存在“队头阻塞”的问题，只不过问题不是在 HTTP 这一层面，而是在 TCP 这一层。</p>\n<p><strong>HTTP&#x2F;2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP&#x2F;2 应用层才能从内核中拿到数据，这就是 HTTP&#x2F;2 队头阻塞问题。</strong></p>\n<h2 id=\"HTTP-x2F-3\"><a href=\"#HTTP-x2F-3\" class=\"headerlink\" title=\"HTTP&#x2F;3\"></a>HTTP&#x2F;3</h2><h3 id=\"网络迁移需要重新连接\"><a href=\"#网络迁移需要重新连接\" class=\"headerlink\" title=\"网络迁移需要重新连接\"></a>网络迁移需要重新连接</h3><p>一个 TCP 连接是由四元组（源 IP 地址，源端口，目标 IP 地址，目标端口）确定的，这意味着如果 IP 地址或者端口变动了，就会导致需要 TCP 与 TLS 重新握手，这不利于移动设备切换网络的场景，比如 4G 网络环境切换成 WIFI。</p>\n<p>这些问题都是 TCP 协议固有的问题，无论应用层的 HTTP&#x2F;2 在怎么设计都无法逃脱。要解决这个问题，就必须把<strong>传输层协议替换成 UDP</strong>，这个大胆的决定，HTTP&#x2F;3 做了！</p>\n<h3 id=\"QUIC-协议的特点\"><a href=\"#QUIC-协议的特点\" class=\"headerlink\" title=\"QUIC 协议的特点\"></a>QUIC 协议的特点</h3><p>我们深知，UDP 是一个简单、不可靠的传输协议，而且是 UDP 包之间是无序的，也没有依赖关系。</p>\n<p>而且，UDP 是不需要连接的，也就不需要握手和挥手的过程，所以天然的就比 TCP 快。</p>\n<p>当然，HTTP&#x2F;3 不仅仅只是简单将传输协议替换成了 UDP，还基于 UDP 协议在「应用层」实现了 <strong>QUIC 协议</strong>，它具有类似 TCP 的连接管理、拥塞窗口、流量控制的网络特性，相当于将不可靠传输的 UDP 协议变成“可靠”的了，所以不用担心数据包丢失的问题。</p>\n<p>QUIC 协议的优点有很多，这里举例几个，比如：</p>\n<ul>\n<li>无队头阻塞；</li>\n<li>更快的连接建立；</li>\n<li>连接迁移</li>\n</ul>\n<h4 id=\"无队头阻塞\"><a href=\"#无队头阻塞\" class=\"headerlink\" title=\"无队头阻塞\"></a>无队头阻塞</h4><p>QUIC 协议也有类似 HTTP&#x2F;2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。</p>\n<p>由于 QUIC 使用的传输协议是 UDP，UDP 不关心数据包的顺序，如果数据包丢失，UDP 也不关心。</p>\n<p>不过 QUIC 协议会保证数据包的可靠性，每个数据包都有一个序号唯一标识。当某个流中的一个数据包丢失了，即使该流的其他数据包到达了，数据也无法被 HTTP&#x2F;3 读取，直到 QUIC 重传丢失的报文，数据才会交给 HTTP&#x2F;3。</p>\n<p>而其他流的数据报文只要被完整接收，HTTP&#x2F;3 就可以读取到数据。这与 HTTP&#x2F;2 不同，HTTP&#x2F;2 只要某个流中的数据包丢失了，其他流也会因此受影响。</p>\n<p>所以，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。</p>\n<h4 id=\"更快的连接建立\"><a href=\"#更快的连接建立\" class=\"headerlink\" title=\"更快的连接建立\"></a>更快的连接建立</h4><p>对于 HTTP&#x2F;1 和 HTTP&#x2F;2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。</p>\n<p>HTTP&#x2F;3 在传输数据前虽然需要 QUIC 协议握手，这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。</p>\n<p>但是 HTTP&#x2F;3 的 QUIC 协议并不是与 TLS 分层，而是<strong>QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果</strong>。</p>\n<h4 id=\"连接迁移\"><a href=\"#连接迁移\" class=\"headerlink\" title=\"连接迁移\"></a>连接迁移</h4><p>那么当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接，而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p>\n<p>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong>来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p>\n<h3 id=\"HTTP-x2F-3-协议\"><a href=\"#HTTP-x2F-3-协议\" class=\"headerlink\" title=\"HTTP&#x2F;3 协议\"></a>HTTP&#x2F;3 协议</h3><p>根据帧类型的不同，大体上分为数据帧和控制帧两大类，HEADERS 帧（HTTP 头部）和 DATA 帧（HTTP 包体）属于数据帧。</p>\n<p>HTTP&#x2F;3 在头部压缩算法这一方面也做了升级，升级成了 <strong>QPACK</strong>。与 HTTP&#x2F;2 中的 HPACK 编码方式相似，HTTP&#x2F;3 中的 QPACK 也采用了静态表、动态表及 Huffman 编码。</p>\n<p>对于静态表的变化，HTTP&#x2F;2 中的 HPACK 的静态表只有 61 项，而 HTTP&#x2F;3 中的 QPACK 的静态表扩大到 91 项。</p>\n<p>HTTP&#x2F;2 和 HTTP&#x2F;3 的 Huffman 编码并没有多大不同，但是动态表编解码方式不同。</p>\n<p>所谓的动态表，在首次请求-响应后，双方会将未包含在静态表中的 Header 项更新各自的动态表，接着后续传输时仅用 1 个数字表示，然后对方可以根据这 1 个数字从动态表查到对应的数据，就不必每次都传输长长的数据，大大提升了编码效率。</p>\n<p>可以看到，<strong>动态表是具有时序性的，如果首次出现的请求发生了丢包，后续的收到请求，对方就无法解码出 HPACK 头部，因为对方还没建立好动态表，因此后续的请求解码会阻塞到首次请求中丢失的数据包重传过来</strong>。</p>\n<p>HTTP&#x2F;3 的 QPACK 解决了这一问题，那它是如何解决的呢？</p>\n<p>QUIC 会有两个特殊的单向流，所谓的单向流只有一端可以发送消息，双向则指两端都可以发送消息，传输 HTTP 消息时用的是双向流，这两个单向流的用法：</p>\n<ul>\n<li>一个叫 QPACK Encoder Stream， 用于将一个字典（key-value）传递给对方，比如面对不属于静态表的 HTTP 请求头部，客户端可以通过这个 Stream 发送字典；</li>\n<li>一个叫 QPACK Decoder Stream，用于响应对方，告诉它刚发的字典已经更新到自己的本地动态表了，后续就可以使用这个字典来编码了。</li>\n</ul>\n<p>这两个特殊的单向流是用来<strong>同步双方的动态表</strong>，编码方收到解码方更新确认的通知后，才使用动态表编码 HTTP 头部。</p>\n<p>HTTP&#x2F;2 虽然具有多个流并发传输的能力，但是传输层是 TCP 协议，于是存在以下缺陷：</p>\n<ul>\n<li><strong>队头阻塞</strong>，HTTP&#x2F;2 多个请求跑在一个 TCP 连接中，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，应用层也无法从内核中读取到这部分数据，从 HTTP 视角看，就是多个请求被阻塞了；</li>\n<li><strong>TCP 和 TLS 握手时延</strong>，TCL 三次握手和 TLS 四次握手，共有 3-RTT 的时延；</li>\n<li><strong>连接迁移需要重新连接</strong>，移动设备从 4G 网络环境切换到 WIFI 时，由于 TCP 是基于四元组来确认一条 TCP 连接的，那么网络环境变化后，就会导致 IP 地址或端口变化，于是 TCP 只能断开连接，然后再重新建立连接，切换网络环境的成本高；</li>\n</ul>\n<p>HTTP&#x2F;3 就将传输层从 TCP 替换成了 UDP，并在 UDP 协议上开发了 QUIC 协议，来保证数据的可靠传输。</p>\n<p>QUIC 协议的特点：</p>\n<ul>\n<li><strong>无队头阻塞</strong>，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，也不会有底层协议限制，某个流发生丢包了，只会影响该流，其他流不受影响；</li>\n<li><strong>建立连接速度快</strong>，因为 QUIC 内部包含 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与 TLS 密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。</li>\n<li><strong>连接迁移</strong>，QUIC 协议没有用四元组的方式来“绑定”连接，而是通过「连接 ID 」来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本；</li>\n</ul>\n","text":" 本文参考了小林coding以及自顶向下方法等计算机网络教程，写了一篇个人的笔记，其中也包含了本人对于一些小问题的记录和思考，以及整体框架的梳理。 基础知识 对于不同设备间的通信就需要使用网络通信，而设备是多样性的，所以要兼容设备就需要一套通用的网络协议 TCP&#x2F;IP网...","link":"","photos":[],"count_time":{"symbolsCount":"61k","symbolsTime":"56 mins."},"categories":[{"name":"计算机网络","slug":"计算机网络","count":1,"path":"api/categories/计算机网络.json"}],"tags":[{"name":"计算机网络","slug":"计算机网络","count":2,"path":"api/tags/计算机网络.json"},{"name":"基础知识","slug":"基础知识","count":2,"path":"api/tags/基础知识.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86\"><span class=\"toc-text\">基础知识</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TCP-x2F-IP%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">TCP&#x2F;IP网络模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BA%94%E7%94%A8%E5%B1%82\"><span class=\"toc-text\">应用层</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BC%A0%E8%BE%93%E5%B1%82\"><span class=\"toc-text\">传输层</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BD%91%E7%BB%9C%E5%B1%82\"><span class=\"toc-text\">网络层</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82\"><span class=\"toc-text\">网络接口层</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%8E%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">从输入网址到页面显示过程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E8%A7%A3%E6%9E%90URL\"><span class=\"toc-text\">1.解析URL</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E7%94%9F%E6%88%90HTTP%E8%AF%B7%E6%B1%82%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">2.生成HTTP请求信息</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E7%9C%9F%E5%AE%9E%E5%9C%B0%E5%9D%80%E6%9F%A5%E8%AF%A2-DNS\"><span class=\"toc-text\">3.真实地址查询-DNS</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E5%8D%8F%E8%AE%AE%E6%A0%88\"><span class=\"toc-text\">4.协议栈</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-TCP\"><span class=\"toc-text\">5.TCP</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-IP\"><span class=\"toc-text\">6.IP</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-MAC\"><span class=\"toc-text\">7.MAC</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-%E7%BD%91%E5%8D%A1\"><span class=\"toc-text\">8.网卡</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-%E4%BA%A4%E6%8D%A2%E6%9C%BA\"><span class=\"toc-text\">9.交换机</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-%E8%B7%AF%E7%94%B1%E5%99%A8\"><span class=\"toc-text\">10.路由器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#11-%E6%95%B0%E6%8D%AE%E5%8C%85%E6%8B%86%E8%A7%A3\"><span class=\"toc-text\">11.数据包拆解</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Liunx%E7%B3%BB%E7%BB%9F%E6%94%B6%E5%8F%91%E7%BD%91%E7%BB%9C%E5%8C%85\"><span class=\"toc-text\">Liunx系统收发网络包</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#OSI%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">OSI七层网络模型</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Liunx%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88\"><span class=\"toc-text\">Liunx网络协议栈</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Linux-%E6%8E%A5%E6%94%B6%E7%BD%91%E7%BB%9C%E5%8C%85%E7%9A%84%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">Linux 接收网络包的流程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E6%84%9F%E7%9F%A5%E7%BD%91%E7%BB%9C%E5%8C%85%E5%88%B0%E8%BE%BE\"><span class=\"toc-text\">操作系统如何感知网络包到达</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88\"><span class=\"toc-text\">网络协议栈</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Linux-%E5%8F%91%E9%80%81%E7%BD%91%E7%BB%9C%E5%8C%85%E7%9A%84%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">Linux 发送网络包的流程</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#HTTP\"><span class=\"toc-text\">HTTP</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">HTTP 基本概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">协议</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BC%A0%E8%BE%93\"><span class=\"toc-text\">传输</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B6%85%E6%96%87%E6%9C%AC\"><span class=\"toc-text\">超文本</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP-%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\"><span class=\"toc-text\">HTTP 常见的状态码有哪些？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP-%E5%B8%B8%E8%A7%81%E5%AD%97%E6%AE%B5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\"><span class=\"toc-text\">HTTP 常见字段有哪些？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#GET-%E4%B8%8E-POST\"><span class=\"toc-text\">GET 与 POST</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP-%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">HTTP 缓存技术</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">强制缓存</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">协商缓存</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP-%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">HTTP 特性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HTTP-x2F-1-1-%E7%9A%84%E4%BC%98%E7%82%B9\"><span class=\"toc-text\">HTTP&#x2F;1.1 的优点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HTTP-x2F-1-1-%E7%9A%84%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">HTTP&#x2F;1.1 的缺点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HTTP-x2F-1-1-%E7%9A%84%E6%80%A7%E8%83%BD\"><span class=\"toc-text\">HTTP&#x2F;1.1 的性能</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP-%E4%B8%8E-HTTPS\"><span class=\"toc-text\">HTTP 与 HTTPS</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HTTPS%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">HTTPS优化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HTTPS-%E6%98%AF%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5\"><span class=\"toc-text\">HTTPS 是如何建立连接</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A0%A1%E9%AA%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%9A%84%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">客户端校验数字证书的流程</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HTTPS-%E7%9A%84%E5%BA%94%E7%94%A8%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%8C%E6%95%B4%E6%80%A7\"><span class=\"toc-text\">HTTPS 的应用数据如何保证完整性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HTTPS-%E4%B8%80%E5%AE%9A%E5%AE%89%E5%85%A8%E5%8F%AF%E9%9D%A0\"><span class=\"toc-text\">HTTPS 一定安全可靠</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP-x2F-1-1%E3%80%81HTTP-x2F-2%E3%80%81HTTP-x2F-3-%E6%BC%94%E5%8F%98\"><span class=\"toc-text\">HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HTTP-x2F-1-1-%E7%9B%B8%E6%AF%94-HTTP-x2F-1-0-%E6%8F%90%E9%AB%98%E4%BA%86%E4%BB%80%E4%B9%88%E6%80%A7%E8%83%BD%EF%BC%9F\"><span class=\"toc-text\">HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HTTP-x2F-2-%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F\"><span class=\"toc-text\">HTTP&#x2F;2 做了什么优化？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HTTP-x2F-2-%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E9%99%B7%EF%BC%9F\"><span class=\"toc-text\">HTTP&#x2F;2 有什么缺陷？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HTTP-x2F-3-%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%EF%BC%9F\"><span class=\"toc-text\">HTTP&#x2F;3 做了哪些优化？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP-x2F-1-1%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">HTTP&#x2F;1.1如何优化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%8F%91%E9%80%81-HTTP-%E8%AF%B7%E6%B1%82%EF%BC%9F\"><span class=\"toc-text\">如何避免发送 HTTP 请求？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91-HTTP-%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0%EF%BC%9F\"><span class=\"toc-text\">如何减少 HTTP 请求次数？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%87%8F%E5%B0%91%E9%87%8D%E5%AE%9A%E5%90%91%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0\"><span class=\"toc-text\">减少重定向请求次数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%90%88%E5%B9%B6%E8%AF%B7%E6%B1%82\"><span class=\"toc-text\">合并请求</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BB%B6%E8%BF%9F%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82\"><span class=\"toc-text\">延迟发送请求</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91-HTTP-%E5%93%8D%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B0%8F%EF%BC%9F\"><span class=\"toc-text\">如何减少 HTTP 响应的数据大小？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%97%A0%E6%8D%9F%E5%8E%8B%E7%BC%A9\"><span class=\"toc-text\">无损压缩</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9C%89%E6%8D%9F%E5%8E%8B%E7%BC%A9\"><span class=\"toc-text\">有损压缩</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTPS-RSA-%E6%8F%A1%E6%89%8B%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">HTTPS RSA 握手解析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#TLS-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B\"><span class=\"toc-text\">TLS 第一次握手</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#TLS-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B\"><span class=\"toc-text\">TLS 第二次握手</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%AA%8C%E8%AF%81%E8%AF%81%E4%B9%A6\"><span class=\"toc-text\">客户端验证证书</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%92%8C-CA-%E6%9C%BA%E6%9E%84\"><span class=\"toc-text\">数字证书和 CA 机构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%AD%BE%E5%8F%91%E5%92%8C%E9%AA%8C%E8%AF%81%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">数字证书签发和验证流程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AF%81%E4%B9%A6%E9%93%BE\"><span class=\"toc-text\">证书链</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#TLS-%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B\"><span class=\"toc-text\">TLS 第三次握手</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#TLS-%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B\"><span class=\"toc-text\">TLS 第四次握手</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#RSA-%E7%AE%97%E6%B3%95%E7%9A%84%E7%BC%BA%E9%99%B7\"><span class=\"toc-text\">RSA 算法的缺陷</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTPS-ECDHE-%E6%8F%A1%E6%89%8B%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">HTTPS ECDHE 握手解析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0\"><span class=\"toc-text\">离散对数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#DH-%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">DH 算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#DHE-%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">DHE 算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ECDHE-%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">ECDHE 算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ECDHE-%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">ECDHE 握手过程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#TLS-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B-1\"><span class=\"toc-text\">TLS 第一次握手</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#TLS-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B-1\"><span class=\"toc-text\">TLS 第二次握手</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#TLS-%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-1\"><span class=\"toc-text\">TLS 第三次握手</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#TLS-%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B-1\"><span class=\"toc-text\">TLS 第四次握手</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTPS-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%EF%BC%9F\"><span class=\"toc-text\">HTTPS 如何优化？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A1%AC%E4%BB%B6%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">硬件优化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BD%AF%E4%BB%B6%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">软件优化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E8%AE%AE%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">协议优化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">密钥交换算法优化</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#TLS-%E5%8D%87%E7%BA%A7\"><span class=\"toc-text\">TLS 升级</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%81%E4%B9%A6%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">证书优化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BC%A0%E8%BE%93%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">传输优化</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%AA%8C%E8%AF%81%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">验证优化</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BC%9A%E8%AF%9D%E5%A4%8D%E7%94%A8\"><span class=\"toc-text\">会话复用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Session-ID\"><span class=\"toc-text\">Session ID</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Session-Ticket\"><span class=\"toc-text\">Session Ticket</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Pre-shared-Key\"><span class=\"toc-text\">Pre-shared Key</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP-x2F-2\"><span class=\"toc-text\">HTTP&#x2F;2</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%BC%E5%AE%B9-HTTP-x2F-1-1\"><span class=\"toc-text\">兼容 HTTP&#x2F;1.1</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E8%A1%A8%E7%BC%96%E7%A0%81\"><span class=\"toc-text\">静态表编码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81%E8%A1%A8%E7%BC%96%E7%A0%81\"><span class=\"toc-text\">动态表编码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B8%A7\"><span class=\"toc-text\">二进制帧</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B9%B6%E5%8F%91%E4%BC%A0%E8%BE%93\"><span class=\"toc-text\">并发传输</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%BB%E5%8A%A8%E6%8E%A8%E9%80%81%E8%B5%84%E6%BA%90\"><span class=\"toc-text\">服务器主动推送资源</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP-x2F-3\"><span class=\"toc-text\">HTTP&#x2F;3</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BD%91%E7%BB%9C%E8%BF%81%E7%A7%BB%E9%9C%80%E8%A6%81%E9%87%8D%E6%96%B0%E8%BF%9E%E6%8E%A5\"><span class=\"toc-text\">网络迁移需要重新连接</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#QUIC-%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">QUIC 协议的特点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%97%A0%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E\"><span class=\"toc-text\">无队头阻塞</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9B%B4%E5%BF%AB%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B\"><span class=\"toc-text\">更快的连接建立</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%9E%E6%8E%A5%E8%BF%81%E7%A7%BB\"><span class=\"toc-text\">连接迁移</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HTTP-x2F-3-%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">HTTP&#x2F;3 协议</span></a></li></ol></li></ol></li></ol>","author":{"name":"依水何安","slug":"blog-author","avatar":"/img/123.png","link":"/","description":"一个抽象的码农","socials":{"github":"https://github.com/jankin12138","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/img/bilibili.png","link":"https://space.bilibili.com/14624621?spm_id_from=333.1007.0.0"},"leetcode":{"icon":"/img/leetcode.png","link":"https://leetcode.cn/u/yi-shui-he-an-o/"}}}},"mapped":true,"prev_post":{"title":"操作系统笔记","uid":"3a69ec9c6ae67f12a8733f1c82dc14ae","slug":"操作系统笔记","date":"2022-10-24T13:03:48.000Z","updated":"2022-11-01T14:16:29.975Z","comments":true,"path":"api/articles/操作系统笔记.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/QQ截图20221024210529.1hr147awjhds.webp","text":"本文参考了小林coding,csapp等操作系统教程，以及Websever的一些框架和思路。写了一篇个人的笔记，其中也包含了本人对于一些小问题的记录和思考，以及整体框架的梳理。 进程管理快速了解可以参考： 进程 我们编写的代码只是一个存储在硬盘的静态文件，通过编译后就会生成二进制...","link":"","photos":[],"count_time":{"symbolsCount":"59k","symbolsTime":"54 mins."},"categories":[{"name":"操作系统","slug":"操作系统","count":2,"path":"api/categories/操作系统.json"}],"tags":[{"name":"操作系统","slug":"操作系统","count":2,"path":"api/tags/操作系统.json"},{"name":"基础知识","slug":"基础知识","count":2,"path":"api/tags/基础知识.json"}],"author":{"name":"依水何安","slug":"blog-author","avatar":"/img/123.png","link":"/","description":"一个抽象的码农","socials":{"github":"https://github.com/jankin12138","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/img/bilibili.png","link":"https://space.bilibili.com/14624621?spm_id_from=333.1007.0.0"},"leetcode":{"icon":"/img/leetcode.png","link":"https://leetcode.cn/u/yi-shui-he-an-o/"}}}}},"next_post":{"title":"mysql常用语句","uid":"d198ad69ab98260fa3db17c94f83ffaa","slug":"mysql常用语句","date":"2022-10-17T09:13:29.000Z","updated":"2022-10-19T15:49:44.540Z","comments":true,"path":"api/articles/mysql常用语句.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/QQ截图20221017172054.3b034g09kf40.webp","text":" 这一章是纯粹的个人笔记，所以不会按照目录的方式分类各种语句，因为有点麻烦，如果有空的话可能会整理吧，主要还是注释形式来记录一些语句的用法（因为我的mysql使用的是DataGrip所以可以比较方便的记录语句，如果有兴趣我也可以出一期安装和配置mysql已经DG的教程） #使用M...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"数据库","slug":"数据库","count":7,"path":"api/categories/数据库.json"}],"tags":[{"name":"MySQL","slug":"MySQL","count":7,"path":"api/tags/MySQL.json"},{"name":"框架学习","slug":"框架学习","count":7,"path":"api/tags/框架学习.json"},{"name":"基础概念","slug":"基础概念","count":7,"path":"api/tags/基础概念.json"}],"author":{"name":"依水何安","slug":"blog-author","avatar":"/img/123.png","link":"/","description":"一个抽象的码农","socials":{"github":"https://github.com/jankin12138","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/img/bilibili.png","link":"https://space.bilibili.com/14624621?spm_id_from=333.1007.0.0"},"leetcode":{"icon":"/img/leetcode.png","link":"https://leetcode.cn/u/yi-shui-he-an-o/"}}}}}}