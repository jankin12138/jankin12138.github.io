{"title":"MySQL高可用","uid":"e7ec4f0245ca61bcdc5ddc21332c4d05","slug":"MySQL高可用","date":"2022-09-26T13:48:46.000Z","updated":"2022-09-26T14:16:44.186Z","comments":true,"path":"api/articles/MySQL高可用.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/QQ截图20220926215134.1nl5iiure6qo.webp","content":"<h1 id=\"MySQL-主备的基本原理\"><a href=\"#MySQL-主备的基本原理\" class=\"headerlink\" title=\"MySQL 主备的基本原理\"></a>MySQL 主备的基本原理</h1><div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/QQ截图20220926215921.7k3ie5b4qp00.webp\"/>\n</div>\n\n<p>在状态 1 中，客户端的读写都直接访问节点 A，而节点 B 是 A 的备库，只是将 A 的更新都同步过来，到本地执行。这样可以保持节点 B 和 A 的数据是相同的。</p>\n<p>当需要切换的时候，就切成状态 2。这时候客户端读写访问的都是节点 B，而节点 A 是 B 的备库。</p>\n<p>在状态 1 中，虽然节点 B 没有被直接访问，但是我依然建议你把节点 B（也就是备库）设置成只读（readonly）模式。这样做，有以下几个考虑：</p>\n<ol>\n<li>有时候一些运营类的查询语句会被放到备库上去查，设置为只读可以防止误操作；</li>\n<li>防止切换逻辑有 bug，比如切换过程中出现双写，造成主备不一致；</li>\n<li>可以用 readonly 状态，来判断节点的角色。</li>\n</ol>\n<p>备库 B 跟主库 A 之间维持了一个长连接。主库 A 内部有一个线程，专门用于服务备库 B 的这个长连接。<strong>一个事务日志同步的完整过程</strong>是这样的：</p>\n<ol>\n<li>在备库 B 上通过 change master 命令，设置主库 A 的 IP、端口、用户名、密码，以及要从哪个位置开始请求 binlog，这个位置包含文件名和日志偏移量。</li>\n<li>在备库 B 上执行 start slave 命令，这时候备库会启动两个线程，就是图中的 io_thread 和 sql_thread。其中 io_thread 负责与主库建立连接。</li>\n<li>主库 A 校验完用户名、密码后，开始按照备库 B 传过来的位置，从本地读取 binlog，发给 B。</li>\n<li>备库 B 拿到 binlog 后，写到本地文件，称为中转日志（relay log）。</li>\n<li>sql_thread 读取中转日志，解析出日志里的命令，并执行。</li>\n</ol>\n<h2 id=\"binlog-的三种格式对比\"><a href=\"#binlog-的三种格式对比\" class=\"headerlink\" title=\"binlog 的三种格式对比\"></a>binlog 的三种格式对比</h2><h3 id=\"statement-格式\"><a href=\"#statement-格式\" class=\"headerlink\" title=\"statement 格式\"></a>statement 格式</h3><div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/QQ截图20220926220756.5ademsasfd00.webp\"/>\n</div>\n\n<ul>\n<li>第一行 SET @@SESSION.GTID_NEXT&#x3D;’ANONYMOUS’你可以先忽略，后面文章我们会在介绍主备切换的时候再提到；</li>\n<li>第二行是一个 BEGIN，跟第四行的 commit 对应，表示中间是一个事务；</li>\n<li>第三行就是真实执行的语句了。可以看到，在真实执行的 delete 命令之前，还有一个“use ‘test’”命令。这条命令不是我们主动执行的，而是 MySQL 根据当前要操作的表所在的数据库，自行添加的。这样做可以保证日志传到备库去执行的时候，不论当前的工作线程在哪个库里，都能够正确地更新到 test 库的表 t。<br>use ‘test’命令之后的 delete 语句，就是我们输入的 SQL 原文了。可以看到，binlog“忠实”地记录了 SQL 命令，甚至连注释也一并记录了。</li>\n<li>最后一行是一个 COMMIT。你可以看到里面写着 xid&#x3D;61。是用来决定binlog是否完整的。</li>\n</ul>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p><p>可以看到，运行这条 delete 命令产生了一个 warning，原因是当前 binlog 设置的是 statement 格式，并且语句中有 limit，所以这个命令可能是 unsafe 的。</p>\n<p>为什么这么说呢？这是因为 delete 带 limit，很可能会出现主备数据不一致的情况。比如上面这个例子：</p>\n<ol>\n<li>如果 delete 语句使用的是索引 a，那么会根据索引 a 找到第一个满足条件的行，也就是说删除的是 a&#x3D;4 这一行；</li>\n<li>但如果使用的是索引 t_modified，那么删除的就是 t_modified&#x3D;’2018-11-09’也就是 a&#x3D;5 这一行。</li>\n</ol>\n<p>由于 statement 格式下，记录到 binlog 里的是语句原文，因此可能会出现这样一种情况：在主库执行这条 SQL 语句的时候，用的是索引 a；而在备库执行这条 SQL 语句的时候，却使用了索引 t_modified。因此，MySQL 认为这样写是有风险的。</p>\n</p>\n</div>\n<h3 id=\"row格式\"><a href=\"#row格式\" class=\"headerlink\" title=\"row格式\"></a>row格式</h3><div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/QQ截图20220926221233.64y1c3e2inw0.webp\"/>\n</div>\n\n<p>可以看到，与 statement 格式的 binlog 相比，前后的 BEGIN 和 COMMIT 是一样的。但是，row 格式的 binlog 里没有了 SQL 语句的原文，而是替换成了两个 event：Table_map 和 Delete_rows。</p>\n<ol>\n<li>Table_map event，用于说明接下来要操作的表是 test 库的表 t;</li>\n<li>Delete_rows event，用于定义删除的行为。</li>\n</ol>\n<div align=center>\n<img src=\"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/QQ截图20220926221621.3q8fkvzuons0.webp\"/>\n</div>\n","text":"MySQL 主备的基本原理 在状态 1 中，客户端的读写都直接访问节点 A，而节点 B 是 A 的备库，只是将 A 的更新都同步过来，到本地执行。这样可以保持节点 B 和 A 的数据是相同的。 当需要切换的时候，就切成状态 2。这时候客户端读写访问的都是节点 B，而节点 A 是 ...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"数据库","slug":"数据库","count":6,"path":"api/categories/数据库.json"}],"tags":[{"name":"MySQL","slug":"MySQL","count":6,"path":"api/tags/MySQL.json"},{"name":"框架学习","slug":"框架学习","count":6,"path":"api/tags/框架学习.json"},{"name":"基础概念","slug":"基础概念","count":6,"path":"api/tags/基础概念.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#MySQL-%E4%B8%BB%E5%A4%87%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">MySQL 主备的基本原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#binlog-%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A0%BC%E5%BC%8F%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">binlog 的三种格式对比</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#statement-%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">statement 格式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#row%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">row格式</span></a></li></ol></li></ol></li></ol>","author":{"name":"依水何安","slug":"blog-author","avatar":"/img/b8d3b3c382fa44e5c92a361d33e0c616_hd.png","link":"/","description":"一个抽象的码农","socials":{"github":"https://github.com/jankin12138","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/img/bilibili.png","link":"https://space.bilibili.com/14624621?spm_id_from=333.1007.0.0"}}}},"mapped":true,"prev_post":{"title":"MySQL框架&日志系统","uid":"77b268d8a20b2f9b34be681cdfe52894","slug":"MySQL框架","date":"2022-08-29T10:22:15.000Z","updated":"2022-09-23T10:47:06.581Z","comments":true,"path":"api/articles/MySQL框架.json","keywords":null,"cover":"/img/test01.png","text":" 之前在字节青训营因为大作业的相关内容也接触过一些数据库方向的知识，但一直苦于没有系统性的学习和整理，所以这系列文章来总结和记录一些，个人觉得比较重要的内容，以便以后复习使用。主要参考文章是极客时间的MySQL45讲：MySQL 实战 45 讲 MySQL框架 连接器 连接器负责...","link":"","photos":[],"count_time":{"symbolsCount":"8.8k","symbolsTime":"8 mins."},"categories":[{"name":"数据库","slug":"数据库","count":6,"path":"api/categories/数据库.json"}],"tags":[{"name":"MySQL","slug":"MySQL","count":6,"path":"api/tags/MySQL.json"},{"name":"框架学习","slug":"框架学习","count":6,"path":"api/tags/框架学习.json"},{"name":"基础概念","slug":"基础概念","count":6,"path":"api/tags/基础概念.json"}],"author":{"name":"依水何安","slug":"blog-author","avatar":"/img/b8d3b3c382fa44e5c92a361d33e0c616_hd.png","link":"/","description":"一个抽象的码农","socials":{"github":"https://github.com/jankin12138","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/img/bilibili.png","link":"https://space.bilibili.com/14624621?spm_id_from=333.1007.0.0"}}}},"feature":true},"next_post":{"title":"MySQL幻读","uid":"298ae6749824eedc891feac490554768","slug":"MySQL幻读","date":"2022-09-25T15:36:04.000Z","updated":"2022-09-25T17:14:06.447Z","comments":true,"path":"api/articles/MySQL幻读.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/QQ截图20220925233721.3kvfyk9f5dw0.webp","text":" 幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。 提示 这里对“幻读”做一个说明： 在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。 上面 session B 的修改结果，被 ...","link":"","photos":[],"count_time":{"symbolsCount":819,"symbolsTime":"1 mins."},"categories":[{"name":"数据库","slug":"数据库","count":6,"path":"api/categories/数据库.json"}],"tags":[{"name":"MySQL","slug":"MySQL","count":6,"path":"api/tags/MySQL.json"},{"name":"框架学习","slug":"框架学习","count":6,"path":"api/tags/框架学习.json"},{"name":"基础概念","slug":"基础概念","count":6,"path":"api/tags/基础概念.json"}],"author":{"name":"依水何安","slug":"blog-author","avatar":"/img/b8d3b3c382fa44e5c92a361d33e0c616_hd.png","link":"/","description":"一个抽象的码农","socials":{"github":"https://github.com/jankin12138","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/img/bilibili.png","link":"https://space.bilibili.com/14624621?spm_id_from=333.1007.0.0"}}}}}}