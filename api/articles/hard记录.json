{"title":"hard记录","uid":"1305302b447db5e66b7e5e506037fc4a","slug":"hard记录","date":"2022-09-26T10:08:53.000Z","updated":"2022-10-26T04:00:26.984Z","comments":true,"path":"api/articles/hard记录.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/QQ截图20221003181824.3vpupn3ylyg0.webp","content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>最近做周赛基本都是三题，哪怕半小时以内做完三题，T4也没什么思路，因此专门记录一下周赛和平常遇到的一些有代表性思路的hard题也算是继续提升一下，希望以后可以成为AK选手。</p></blockquote>\n<h1 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h1><h2 id=\"2430-对字母串可执行的最大删除数（313场周赛T4）\"><a href=\"#2430-对字母串可执行的最大删除数（313场周赛T4）\" class=\"headerlink\" title=\"2430. 对字母串可执行的最大删除数（313场周赛T4）\"></a><a href=\"https://leetcode.cn/problems/maximum-deletions-on-a-string/\">2430. 对字母串可执行的最大删除数</a>（313场周赛T4）</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>本题一开始的思路是准备使用hash来记录下，字符串最长前缀，但是错误的贪心了其实这里必须是On^2的，可以<strong>根据数据</strong>来判断复杂度，然后dfs来不及写了，但感觉dfs会超时，不过一般可以用dfs就可以用dp，所以这题的标准思路就是先记忆化最长字符串前缀，当最长前缀大于删除长度表示可以删除，然后在基础上再讲规划+1。</p></blockquote>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int deleteString(string s) &#123;\n        int n &#x3D; s.length();\n        if (equal(s.begin()+1, s.end(), s.begin())) &#x2F;&#x2F; 特判全部相同的情况\n            return n;\n        int lcp[n + 1][n + 1]; &#x2F;&#x2F; lcp[i][j] 表示 s[i:] 和 s[j:] 的最长公共前缀\n        memset(lcp, 0, sizeof(lcp));\n        for (int i &#x3D; n - 1; i &gt;&#x3D; 0; --i)\n            for (int j &#x3D; n - 1; j &gt; i; --j)\n                if (s[i] &#x3D;&#x3D; s[j])\n                    lcp[i][j] &#x3D; lcp[i + 1][j + 1] + 1;\n        int f[n];\n        memset(f, 0, sizeof(f));\n        for (int i &#x3D; 0; i &lt;n; ++i) &#123;\n            for (int j &#x3D; 1; i + j * 2 &lt;&#x3D; n; ++j)\n                if (lcp[i][i + j] &gt;&#x3D; j) &#x2F;&#x2F; 说明 s[i:i+j] &#x3D;&#x3D; s[i+j:i+j*2]\n                    f[i] &#x3D; max(f[i], f[i + j]);\n            ++f[i];\n        &#125;\n        return f[0];\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"801-使序列递增的最小交换次数（22-10-10每日一题）\"><a href=\"#801-使序列递增的最小交换次数（22-10-10每日一题）\" class=\"headerlink\" title=\"801. 使序列递增的最小交换次数（22.10.10每日一题）\"></a><a href=\"https://leetcode.cn/problems/minimum-swaps-to-make-sequences-increasing/\">801. 使序列递增的最小交换次数</a>（22.10.10每日一题）</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这题想到了动态规划，但是因为没有把情况搞清楚所以想简单了，这个题居然是以前周赛的第二题实在是不管相信，状态机DP的精髓就是一个限定死的操作，例如本题只有交换和不交换，那么只要保证前面数组的递增性就无后效性，将状态方程把握清楚就可以了。</p></blockquote>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">class Solution <span class=\"token punctuation\">&#123;</span>\npublic<span class=\"token operator\">:</span>\n    <span class=\"token keyword\">int</span> <span class=\"token function\">minSwap</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> nums1<span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> nums2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> nums1<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">int</span> at <span class=\"token operator\">=</span> a<span class=\"token punctuation\">,</span> bt <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span>\n            a <span class=\"token operator\">=</span> b <span class=\"token operator\">=</span> n<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums1<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> nums1<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> nums2<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> nums2<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>  <span class=\"token punctuation\">&#123;</span>\n                a <span class=\"token operator\">=</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> at<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                b <span class=\"token operator\">=</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">,</span> bt <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums1<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> nums2<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> nums2<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> nums1<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                a <span class=\"token operator\">=</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> bt<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                b <span class=\"token operator\">=</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">,</span> at <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<details class=\"custom-details\">\n<summary>相关问题</summary>\n<p><a href=\"https://leetcode.cn/problems/house-robber/\">198. 打家劫舍</a>(和这种偷与不偷我感觉比较类似)</p>\n<p><a href=\"https://leetcode.cn/problems/house-robber-ii/\">213. 打家劫舍 II</a></p>\n\n</details>\n<h2 id=\"2435-矩阵中和能被-K-整除的路径（314场周赛T4）\"><a href=\"#2435-矩阵中和能被-K-整除的路径（314场周赛T4）\" class=\"headerlink\" title=\"2435. 矩阵中和能被 K 整除的路径（314场周赛T4）\"></a><a href=\"https://leetcode.cn/problems/paths-in-matrix-whose-sum-is-divisible-by-k/\">2435. 矩阵中和能被 K 整除的路径</a>（314场周赛T4）</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>标准的记忆化搜索题，奈何T3太难了浪费了很多时间，最接近AK的一次，这题的难点在于三维记忆化要想到取余作为sum不然的话会TEL，然后需要注意的是溢出的处理，说实话int溢出真的很烦尤其有减法，烦的一批！！！吃了好多发WA。（难得有自己写的代码贴上来的很香！）</p></blockquote>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int numberOfPaths(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int k) &#123;\n        long long res &#x3D;0;\n        vector&lt;vector&lt;vector&lt;long long&gt;&gt;&gt; dp(grid.size(),vector&lt;vector&lt;long long&gt;&gt;(grid[0].size(),vector&lt;long long&gt;(50,-1)));\n        dfs(0,0,grid,k,0,res,dp);\n        res &#x3D; res % 1000000007;\n        return (int)res;\n    &#125;\n    void dfs(int i,int j,vector&lt;vector&lt;int&gt;&gt;&amp; grid, int&amp; k,int sum,long long&amp; res,vector&lt;vector&lt;vector&lt;long long&gt;&gt;&gt;&amp; dp)&#123;\n        sum +&#x3D; grid[i][j];\n        if(dp[i][j][sum%k] !&#x3D; -1)&#123;\n            &#x2F;&#x2F;res &#x3D; res % 1000000007;\n            res +&#x3D; dp[i][j][sum%k];\n            return;\n        &#125;\n        long long tmp &#x3D; res % 1000000007;\n        if(i &#x3D;&#x3D; grid.size()-1 &amp;&amp; j&#x3D;&#x3D;grid[0].size()-1)&#123;\n            if(sum % k &#x3D;&#x3D; 0) res++;\n            return;\n        &#125;\n        if(i &lt; grid.size()-1) dfs(i+1,j,grid,k,sum,res,dp);\n        if(j &lt; grid[0].size()-1) dfs(i,j+1,grid,k,sum,res,dp);\n        dp[i][j][sum%k] &#x3D; (res - tmp)%1000000007;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"1235-规划兼职工作（22-10-22每日一题）\"><a href=\"#1235-规划兼职工作（22-10-22每日一题）\" class=\"headerlink\" title=\"1235. 规划兼职工作（22.10.22每日一题）\"></a><a href=\"https://leetcode.cn/problems/maximum-profit-in-job-scheduling/\">1235. 规划兼职工作</a>（22.10.22每日一题）</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>一开始想法是dfs+记忆化搜索，但其实记忆化的题目都可以dp没有想到很好的状态转移方程，后来看了题解感觉到有一点贪心的味道其实并不算难，但是题解的一些语法特性技巧，非常值得借鉴，也算是个好题目了。</p></blockquote>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int jobScheduling(vector&lt;int&gt; &amp;startTime, vector&lt;int&gt; &amp;endTime, vector&lt;int&gt; &amp;profit) &#123;\n        int n &#x3D; startTime.size();\n        vector&lt;vector&lt;int&gt;&gt; jobs(n);\n        for (int i &#x3D; 0; i &lt; n; i++) &#123;\n            jobs[i] &#x3D; &#123;startTime[i], endTime[i], profit[i]&#125;;\n        &#125;\n        sort(jobs.begin(), jobs.end(), [](const vector&lt;int&gt; &amp;job1, const vector&lt;int&gt; &amp;job2) -&gt; bool &#123;\n            return job1[1] &lt; job2[1];\n        &#125;);\n        vector&lt;int&gt; dp(n + 1);\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n            int k &#x3D; upper_bound(jobs.begin(), jobs.begin() + i - 1, jobs[i - 1][0], [&amp;](int st, const vector&lt;int&gt; &amp;job) -&gt; bool &#123;\n                return st &lt; job[1];\n            &#125;) - jobs.begin();\n            dp[i] &#x3D; max(dp[i - 1], dp[k] + jobs[i - 1][2]);\n        &#125;\n        return dp[n];\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h1 id=\"树状数组-x2F-线段树\"><a href=\"#树状数组-x2F-线段树\" class=\"headerlink\" title=\"树状数组&#x2F;线段树\"></a>树状数组&#x2F;线段树</h1><h2 id=\"2426-满足不等式的数对数目（88场双周赛T4）\"><a href=\"#2426-满足不等式的数对数目（88场双周赛T4）\" class=\"headerlink\" title=\"2426. 满足不等式的数对数目（88场双周赛T4）\"></a><a href=\"https://leetcode.cn/problems/number-of-pairs-satisfying-inequality/\">2426. 满足不等式的数对数目</a>（88场双周赛T4）</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这题的不等式变形我是想到了，然后求出来数组之后没有办法快速的选取满足条件的区间，感觉逻辑出了点问题，知道要用树状数组求和，奈何没有系统的训练，因此最后也没做出来，区间求和问题还是需要熟练掌握这两种结构，因为周赛出现频率极高。这里可以推荐这个视频：<a href=\"https://www.bilibili.com/video/BV1ce411u7qP/?spm_id_from=333.337.search-card.all.click&vd_source=7a497468491eb25a58413f6c8da9f986\">五分钟丝滑动画讲解 | 树状数组</a>来学习树状数组的原理，我觉得讲的特别清楚。</p></blockquote>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class BIT &#123;&#x2F;&#x2F;树状数组的标准写法\nprivate:\n    vector&lt;int&gt; tree;\n\npublic:\n    BIT(int n) : tree(n) &#123;&#125;\n\n    void add(int x) &#123;\n        while (x &lt; tree.size()) &#123;\n            ++tree[x];\n            x +&#x3D; x &amp; -x;\n        &#125;\n    &#125;\n\n    int query(int x) &#123;\n        int res &#x3D; 0;\n        while (x &gt; 0) &#123;\n            res +&#x3D; tree[x];\n            x &amp;&#x3D; x - 1;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\nclass Solution &#123;\npublic:\n    long long numberOfPairs(vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;nums2, int diff) &#123;\n        int n &#x3D; a.size();\n        for (int i &#x3D; 0; i &lt; n; ++i)\n            a[i] -&#x3D; nums2[i];\n        auto b &#x3D; a;\n        sort(b.begin(), b.end()); &#x2F;&#x2F; 配合下面的二分，离散化\n\n        long ans &#x3D; 0L;\n        auto t &#x3D; new BIT(n + 1);\n        for (int x : a) &#123;\n            ans +&#x3D; t-&gt;query(upper_bound(b.begin(), b.end(), x + diff) - b.begin());&#x2F;&#x2F;查询第一个大于x+diff\n            t-&gt;add(lower_bound(b.begin(), b.end(), x) - b.begin() + 1);&#x2F;&#x2F;查询第一个大于等于x\n        &#125;\n        return ans;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<details class=\"custom-details\">\n<summary>相关问题</summary>\n<p><p><a href=\"https://leetcode.cn/problems/count-of-range-sum/\">327. 区间和的个数</a></p>\n<p><a href=\"https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/\">剑指 Offer 51. 数组中的逆序对</a></p>\n</p>\n</details>\n<h1 id=\"单调栈-x2F-队列-x2F-双端队列\"><a href=\"#单调栈-x2F-队列-x2F-双端队列\" class=\"headerlink\" title=\"单调栈&#x2F;队列&#x2F;双端队列\"></a>单调栈&#x2F;队列&#x2F;双端队列</h1><h2 id=\"862-和至少为-K-的最短子数组（22-10-26每日一题）\"><a href=\"#862-和至少为-K-的最短子数组（22-10-26每日一题）\" class=\"headerlink\" title=\"862. 和至少为 K 的最短子数组（22.10.26每日一题）\"></a><a href=\"https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/\">862. 和至少为 K 的最短子数组</a>（22.10.26每日一题）</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这个题前缀和是想到了，其实子数组很容易想到前缀和，但是想要减枝偷过去天方夜谭了哈哈哈，周赛看到有人偷过去，但是肯定不能抱有侥幸心理啊，所以本质上是双端队列来维护最短的可能性，其实双端队列的头和剪是一样的，但是尾巴的维护单调我没有想到，所以还是学艺不精，尤其是单调队列的使用，单调栈最近感觉还可以。</p></blockquote>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int shortestSubarray(vector&lt;int&gt;&amp; nums, int k) &#123;\n        int n &#x3D; nums.size();\n        vector&lt;long&gt; preSumArr(n + 1);\n        for (int i &#x3D; 0; i &lt; n; i++) &#123;\n            preSumArr[i + 1] &#x3D; preSumArr[i] + nums[i];\n        &#125;\n        int res &#x3D; n + 1;\n        deque&lt;int&gt; qu;\n        for (int i &#x3D; 0; i &lt;&#x3D; n; i++) &#123;\n            long curSum &#x3D; preSumArr[i];\n            while (!qu.empty() &amp;&amp; curSum - preSumArr[qu.front()] &gt;&#x3D; k) &#123;\n                res &#x3D; min(res, i - qu.front());\n                qu.pop_front();\n            &#125;\n            while (!qu.empty() &amp;&amp; preSumArr[qu.back()] &gt;&#x3D; curSum) &#123;\n                qu.pop_back();\n            &#125;\n            qu.push_back(i);\n        &#125;\n        return res &lt; n + 1 ? res : -1;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","feature":true,"text":" 最近做周赛基本都是三题，哪怕半小时以内做完三题，T4也没什么思路，因此专门记录一下周赛和平常遇到的一些有代表性思路的hard题也算是继续提升一下，希望以后可以成为AK选手。 动态规划2430. 对字母串可执行的最大删除数（313场周赛T4） 本题一开始的思路是准备使用hash来...","link":"","photos":[],"count_time":{"symbolsCount":"7.2k","symbolsTime":"7 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":1,"path":"api/categories/数据结构.json"}],"tags":[{"name":"算法刷题","slug":"算法刷题","count":1,"path":"api/tags/算法刷题.json"},{"name":"思路记录","slug":"思路记录","count":1,"path":"api/tags/思路记录.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92\"><span class=\"toc-text\">动态规划</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2430-%E5%AF%B9%E5%AD%97%E6%AF%8D%E4%B8%B2%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A0%E9%99%A4%E6%95%B0%EF%BC%88313%E5%9C%BA%E5%91%A8%E8%B5%9BT4%EF%BC%89\"><span class=\"toc-text\">2430. 对字母串可执行的最大删除数（313场周赛T4）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#801-%E4%BD%BF%E5%BA%8F%E5%88%97%E9%80%92%E5%A2%9E%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0%EF%BC%8822-10-10%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%89\"><span class=\"toc-text\">801. 使序列递增的最小交换次数（22.10.10每日一题）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2435-%E7%9F%A9%E9%98%B5%E4%B8%AD%E5%92%8C%E8%83%BD%E8%A2%AB-K-%E6%95%B4%E9%99%A4%E7%9A%84%E8%B7%AF%E5%BE%84%EF%BC%88314%E5%9C%BA%E5%91%A8%E8%B5%9BT4%EF%BC%89\"><span class=\"toc-text\">2435. 矩阵中和能被 K 整除的路径（314场周赛T4）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1235-%E8%A7%84%E5%88%92%E5%85%BC%E8%81%8C%E5%B7%A5%E4%BD%9C%EF%BC%8822-10-22%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%89\"><span class=\"toc-text\">1235. 规划兼职工作（22.10.22每日一题）</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-x2F-%E7%BA%BF%E6%AE%B5%E6%A0%91\"><span class=\"toc-text\">树状数组&#x2F;线段树</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2426-%E6%BB%A1%E8%B6%B3%E4%B8%8D%E7%AD%89%E5%BC%8F%E7%9A%84%E6%95%B0%E5%AF%B9%E6%95%B0%E7%9B%AE%EF%BC%8888%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9BT4%EF%BC%89\"><span class=\"toc-text\">2426. 满足不等式的数对数目（88场双周赛T4）</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%95%E8%B0%83%E6%A0%88-x2F-%E9%98%9F%E5%88%97-x2F-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97\"><span class=\"toc-text\">单调栈&#x2F;队列&#x2F;双端队列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#862-%E5%92%8C%E8%87%B3%E5%B0%91%E4%B8%BA-K-%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84%EF%BC%8822-10-26%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%89\"><span class=\"toc-text\">862. 和至少为 K 的最短子数组（22.10.26每日一题）</span></a></li></ol></li></ol>","author":{"name":"依水何安","slug":"blog-author","avatar":"/img/123.png","link":"/","description":"一个抽象的码农","socials":{"github":"https://github.com/jankin12138","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/img/bilibili.png","link":"https://space.bilibili.com/14624621?spm_id_from=333.1007.0.0"},"leetcode":{"icon":"/img/leetcode.png","link":"https://leetcode.cn/u/yi-shui-he-an-o/"}}}},"mapped":true,"prev_post":{"title":"MySQL高可用","uid":"e7ec4f0245ca61bcdc5ddc21332c4d05","slug":"MySQL高可用","date":"2022-09-26T13:48:46.000Z","updated":"2022-10-05T07:07:06.588Z","comments":true,"path":"api/articles/MySQL高可用.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/QQ截图20220926215134.1nl5iiure6qo.webp","text":"MySQL 主备的基本原理 在状态 1 中，客户端的读写都直接访问节点 A，而节点 B 是 A 的备库，只是将 A 的更新都同步过来，到本地执行。这样可以保持节点 B 和 A 的数据是相同的。 当需要切换的时候，就切成状态 2。这时候客户端读写访问的都是节点 B，而节点 A 是 ...","link":"","photos":[],"count_time":{"symbolsCount":"24k","symbolsTime":"22 mins."},"categories":[{"name":"数据库","slug":"数据库","count":7,"path":"api/categories/数据库.json"}],"tags":[{"name":"MySQL","slug":"MySQL","count":7,"path":"api/tags/MySQL.json"},{"name":"框架学习","slug":"框架学习","count":7,"path":"api/tags/框架学习.json"},{"name":"基础概念","slug":"基础概念","count":7,"path":"api/tags/基础概念.json"}],"author":{"name":"依水何安","slug":"blog-author","avatar":"/img/123.png","link":"/","description":"一个抽象的码农","socials":{"github":"https://github.com/jankin12138","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/img/bilibili.png","link":"https://space.bilibili.com/14624621?spm_id_from=333.1007.0.0"},"leetcode":{"icon":"/img/leetcode.png","link":"https://leetcode.cn/u/yi-shui-he-an-o/"}}}},"feature":true},"next_post":{"title":"WebServer项目笔记","uid":"2acfbdc0062c0ef1a792fc0d6a402d2c","slug":"WebServer项目笔记","date":"2022-10-27T07:02:29.000Z","updated":"2022-10-27T07:21:11.578Z","comments":true,"path":"api/articles/WebServer项目笔记.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/QQ截图20221027152042.6kolkbovop40.webp","text":" 使用C++编写的Liunx系统下的支持多并发的网络服务器，包含Mysql后端和使用 线程池 + 非阻塞socket + epoll(ET和LT均实现) + 事件处理(Reactor和模拟Proactor均实现) 的并发模型，能够使用状态机解析HTTP请求报文，并且实现了同步&#...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"WebServer","slug":"WebServer","count":1,"path":"api/categories/WebServer.json"}],"tags":[{"name":"网络编程","slug":"网络编程","count":1,"path":"api/tags/网络编程.json"},{"name":"多并发实现","slug":"多并发实现","count":1,"path":"api/tags/多并发实现.json"}],"author":{"name":"依水何安","slug":"blog-author","avatar":"/img/123.png","link":"/","description":"一个抽象的码农","socials":{"github":"https://github.com/jankin12138","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/img/bilibili.png","link":"https://space.bilibili.com/14624621?spm_id_from=333.1007.0.0"},"leetcode":{"icon":"/img/leetcode.png","link":"https://leetcode.cn/u/yi-shui-he-an-o/"}}}}}}